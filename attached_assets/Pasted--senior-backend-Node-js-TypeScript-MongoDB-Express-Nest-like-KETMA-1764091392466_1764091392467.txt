Ты — senior backend-разработчик (Node.js + TypeScript + MongoDB + Express/Nest-like) в проекте KETMAR Market (гео-маркет локальных продавцов, MiniApp для Telegram).

Нужно спроектировать и дописать БЭКЕНД (и частично API для фронта) под:

1. Разное время жизни объявлений по группам товаров.
2. Продление / истечение объявлений с пуш-уведомлениями.
3. Одноразовые и «ежедневные» объявления (выпечка, ягоды, еда).
4. Логирование поисков пользователей.
5. Уведомления ПРОДАВЦАМ, когда растёт СПРОС (поиск «велосипед», «выпечка» и т.п.).
6. Уведомления ПОКУПАТЕЛЯМ, когда товар появился после их неудачного поиска.
7. Кросс-предложение: если люди ищут «косить газон», напоминать исполнителям в смежных категориях.

Сделай это аккуратно, модульно, с понятной архитектурой, без привязки к конкретному фреймворку (Express/Nest), но в стиле TypeScript + Mongoose.

========================================================
1. МОДЕЛИ И НАСТРОЙКИ ЖИЗНЕННОГО ЦИКЛА ОБЪЯВЛЕНИЙ
========================================================

1.1. Расширь модель Ad (объявление)

Добавь поля:

```ts
enum AdStatus {
  ACTIVE = 'active',
  SCHEDULED = 'scheduled',   // запланировано
  EXPIRED = 'expired',       // истёк срок
  ARCHIVED = 'archived',     // вручную скрыто
}

enum AdLifetimeType {
  PERISHABLE_DAILY = 'perishable_daily', // выпечка, ягоды, еда “сегодня”
  FAST = 'fast',                         // телефоны, техника, одежда
  MEDIUM = 'medium',                     // авто, колёса, крупная техника
  LONG = 'long',                         // квартиры, дома, участки
}

enum AdRepeatMode {
  NONE = 'none',   // обычное разовое объявление
  DAILY = 'daily', // повторять каждый день (ремесленники, ежедневная выпечка)
}

interface Ad {
  // ...
  status: AdStatus;
  categoryId: ObjectId;
  subcategoryId?: ObjectId;

  lifetimeType: AdLifetimeType; // определяется по категории
  createdAt: Date;
  updatedAt: Date;

  // Время жизни и расписание
  expiresAt?: Date;      // когда объявление должно истечь
  scheduledAt?: Date;    // когда его надо впервые опубликовать (для запланированных)
  repeatMode: AdRepeatMode;
  repeatUntil?: Date | null; // опционально — до какой даты автопубликовать daily

  // Для перishable-тематики (выпечка/ягоды)
  quantity?: number | null;  // например, «20 эклеров»
  isSoldOut?: boolean;       // пометка “распродано”
}


1.2. Настройки по категориям (CategoryLifetimeConfig)

Создай коллекцию с настройками времени жизни по категориям:

interface CategoryLifetimeConfig {
  _id: ObjectId;
  categoryId: ObjectId;

  lifetimeType: AdLifetimeType;

  // базовый TTL в днях
  defaultTtlDays: number;          // сколько живёт объявление до истечения

  // напоминания продавцу
  remindBeforeExpireDays?: number; // за сколько дней до истечения прислать пуш
  remindMidLifetime?: boolean;     // напомнить в середине жизни (для long)
}


Заполни дефолтные значения (можно в seed-скрипте):

PERISHABLE_DAILY: defaultTtlDays = 1

FAST (телефоны/техника/одежда): defaultTtlDays = 7

MEDIUM (авто, колёса, крупная техника): defaultTtlDays = 14 или 21

LONG (квартиры, дома, участки): defaultTtlDays = 30

1.3. Логика установки expiresAt при создании/обновлении объявления

При создании объявления:

Находим CategoryLifetimeConfig по categoryId.

Выставляем:

ad.lifetimeType = config.lifetimeType;
ad.expiresAt = now + config.defaultTtlDays;
ad.status = AdStatus.ACTIVE или SCHEDULED (если scheduledAt > now);


Если repeatMode = DAILY (для ремесленников/постоянной выпечки):

Первое объявление можно публиковать сразу (ACTIVE), с expiresAt = конец текущего дня.

Дополнительно создаём/используем шаблон (либо само объявление переводим в SCHEDULED для будущих дней, а активные инстансы создаём как копии).

Важно: при DAILY-режиме объявление ежедневно переопубликовывается (см. блок cron).

========================================================
2. CRON / WORKER ДЛЯ ЖИЗНЕННОГО ЦИКЛА

Сделай отдельный модуль adLifecycleWorker (может вызываться по cron раз в 5–15 минут + отдельные ежедневные задачи).

2.1. Ежечасный/каждые 5 минут worker:

ИСТЕКШИЕ ОБЪЯВЛЕНИЯ

Находит объявления, у которых status = 'active' и expiresAt <= now.

Меняет статус на EXPIRED.

Отправляет продавцу пуш:

«Ваше объявление “{title}” истекло. Продлить ещё на N дней или архивировать?»

Логирует событие.

При продлении через API:

expiresAt = now + config.defaultTtlDays

status = ACTIVE.

ЗАПЛАНИРОВАННЫЕ ОБЪЯВЛЕНИЯ

Находит объявления, у которых status = 'scheduled' и scheduledAt <= now:

выставляет status = 'active',

ставит expiresAt = now + defaultTtlDays ИЛИ (для ежедневных) до конца текущего дня.

2.2. Ежедневный worker (например, в 00:05)

DAILY РЕЖИМ (повторяющиеся объявления для ремесленников/выпечки):

Находит объявления-шаблоны с repeatMode = DAILY и (repeatUntil либо не истёк).

Для каждого такого объявления:

создаёт новый “активный” экземпляр объявления на сегодня ИЛИ просто перевыставляет статус/даты.

status = ACTIVE

expiresAt = конец сегодняшнего дня.

Старые активные объявления за вчера (по этой цепочке) помечает EXPIRED или ARCHIVED.

REMINDERS (напоминания)

Для объявлений со статусом ACTIVE:

если remindBeforeExpireDays задан и до expiresAt осталось указанное количество дней:
→ пуш продавцу: «Через X дней ваше объявление истечёт. Продлить / изменить цену / улучшить фото?».

Для LONG-категорий (квартиры/дома), если включён remindMidLifetime:
→ в середине срока жизни отправить пуш: «Добавьте новые фото/описание, чтобы привлечь больше покупателей».

========================================================
3. ЛОГИРОВАНИЕ ПОИСКОВ И ПОДПИСКИ НА СПРОС

3.1. Модель SearchLog

interface SearchLog {
  _id: ObjectId;
  userId?: ObjectId;          // если известен
  sessionId?: string;         // можно для анонимов
  query: string;              // оригинальный запрос ("куплю велосипед")
  normalizedQuery: string;    // нормализованный ("велосипед")
  detectedCategoryId?: ObjectId | null; // определённая категория (велосипеды, выпечка и т.п.)
  lat?: number;
  lng?: number;
  radiusKm?: number;
  resultsCount: number;       // сколько объявлений нашлось
  createdAt: Date;
  // флаг, что мы создали alert для этого поиска:
  alertCreated?: boolean;
}


3.2. Модель SearchAlert (подписка на появление товара)

interface SearchAlert {
  _id: ObjectId;
  userId?: ObjectId;
  sessionId?: string;

  normalizedQuery: string;
  detectedCategoryId?: ObjectId | null;

  lat?: number;
  lng?: number;
  radiusKm?: number;

  isActive: boolean;      // можно выключать
  notifiedAt?: Date | null; // когда мы уже уведомили об исполнении
  createdAt: Date;
}


3.3. Логика на /api/ads/search

Каждый запрос поиска (поиск в «Ленте») должен:

Нормализовать текст (lowercase, убрать стоп-слова типа "куплю").

Попытаться определить detectedCategoryId (по словарю ключевых слов: "велосипед", "выпечка", "квартира", etc).

Выполнить поиск объявлений.

Сохранить запись в SearchLog с resultsCount.

Если resultsCount = 0 и пользователь согласен быть уведомлён (можно делать автосогласие при 0 результатов либо через флаг в запросе):

создаём или обновляем SearchAlert:

по (userId|sessionId, normalizedQuery, detectedCategoryId, гео/радиус).

Фронт может дополнительно явно показывать кнопку:

«Сообщить, когда появится такой товар» → отдельный запрос для активации SearchAlert.

========================================================
4. УВЕДОМЛЕНИЯ ПОКУПАТЕЛЯМ ПРИ ПОЯВЛЕНИИ ТОВАРА

При СОЗДАНИИ/АКТИВАЦИИ нового объявления (Ad):

Определяем, к какой категории/подкатегории оно относится и какие ключевые слова (название, описание).

Находим SearchAlert, которые подходят:

либо по совпадению detectedCategoryId,

либо по вхождению normalizedQuery в title/description,

по гео ( lat/lng/радиус ) — расстояние до пользователя <= radiusKm (или разумный default, например 5–10 км).

Тем, кому isActive = true и не было notifiedAt за последний день по этому запросу:

отправляем пуш-уведомление:

«Появилось новое объявление: {title} — рядом с вами. Вы ранее искали “{query}”.»

Обновляем SearchAlert.notifiedAt.

Фронт при переходе по пушу:

открывает «Ленту» на вкладке с готовым поиском и чипом «Вы это искали раньше: {query}».

========================================================
5. УВЕДОМЛЕНИЯ ПРОДАВЦАМ ПРИ ВЫСОКОМ СПРОСЕ

Нужно:

Если много людей в районе ищут «велосипед» → написать тем, кто продавал или может продавать велосипеды.

Если много людей ищут «выпечку» → написать ремесленникам/тем, кто ранее выкладывал выпечку.

Если много людей ищут «косить газон» → предложить мастерам по ремонту/услугам добавить эту услугу.

5.1. Модель DemandStats (агрегация спроса)

interface DemandStats {
  _id: ObjectId;
  normalizedQuery: string;
  detectedCategoryId?: ObjectId | null;
  geoHash: string;         // агрегируем по району/городу
  searchesCount: number;   // за период
  period: 'day' | 'week';
  updatedAt: Date;
}


5.2. Ежечасный/ежедневный worker по спросу

Анализирует SearchLog за последние N часов/дней.

Группирует по (normalizedQuery, detectedCategoryId, geoHash).

Считает searchesCount.

Если searchesCount выше порога (например, ≥ 5 поисков за день):

обновляет/создаёт DemandStats.

5.3. Нотификации продавцам

Для каждой значимой записи в DemandStats (спрос выше порога):

Находим продавцов:

с активными или недавно истёкшими объявлениями в detectedCategoryId в том же geoHash (или рядом),

а также ремесленников/услуг, которые связаны по карте “кросс-категорий”.

Надо завести простой конфиг:

// Пример кросс-связей:
const CROSS_CATEGORY_DEMAND: Record<string, string[]> = {
  'газон': ['услуги-садовника', 'услуги-ремонт-дома'],
  'выпечка': ['ремесленники-выпечка'],
  'велосипед': ['спорт-товары', 'ремонт-велосипедов'],
};


Логика:

Если спрос по запросу “велосипед”:

Продавцам категорий “Велосипеды”, “Спорттовары” в этом районе:
→ пуш: «В вашем районе {X} человек за последние дни искали велосипеды. Хотите подать объявление или обновить свои?»

Если спрос по “выпечка”:

Продавцам с объявлениями категории “Выпечка/еда”:
→ пуш: «В радиусе 1 км люди ищут выпечку. Есть свежая продукция? Добавьте объявление.»

Если спрос по “косить газон”:

Мастерам в услугах (ремонт/садовые работы):
→ пуш: «В вашем районе ищут услугу “косить газон”. Хотите добавить эту услугу к своим?»

========================================================
6. ВЗАИМОДЕЙСТВИЕ С FRONTEND / MINIAPP

Опиши/реализуй минимальные API и договорённости:

6.1. Поиск (лента)

GET /api/ads/search?query=&lat=&lng=&radiusKm=&categoryId=...

Помимо данных объявлений:

логирует SearchLog,

при 0 результатов создаёт/обновляет SearchAlert (при согласии пользователя).

6.2. Подписка на оповещение явно

POST /api/search/alerts

принимает:

query, detectedCategoryId, lat,lng,radius

создаёт SearchAlert (если его ещё нет).

6.3. Получение активных алертов пользователя

GET /api/search/alerts/my

6.4. Продление объявления

POST /api/ads/:id/extend

продлевает expiresAt на defaultTtlDays для категории,

ставит статус ACTIVE,

используется по клику на пуш «Продлить объявление».

6.5. Изменение статуса объявления (архив и т.д.)

POST /api/ads/:id/archive

статус ARCHIVED.

========================================================
7. ПРЕДСТАВЛЕНИЕ ВРЕМЕНИ НА ФРОНТЕ

Для отображения «свежести» объявления верни на фронт:

createdAt

expiresAt

lifetimeType

Фронт преобразует во фразы:

< 1 часа → «только что»

1–24ч → «X часов назад»

1–7 дней → «X дней назад»

7–30 дней → «1 неделю назад»

а также может показать:

«Осталось 3 дня до окончания» (по разнице expiresAt - now).

========================================================
8. ТРЕБОВАНИЯ К КОДУ

Вынеси логику жизненного цикла объявлений (ttl/cron/повторы) в отдельный сервис/модуль:

AdLifecycleService

AdLifecycleWorker (для cron).

Логику поиска/спроса/уведомлений:

SearchLogService

SearchAlertService

DemandStatsService

отдельный worker DemandWorker (агрегация спроса + уведомления продавцам).

Все операции должны быть идемпотентными:

cron не должен ломать состояние при повторных запусках.

В комментариях кратко опиши:

где интегрировать Telegram-уведомления (бот, MiniApp),

какие методы дергаются на пуш.

В конце:

Опиши, какие именно коллекции появились/изменились.

Приведи примеры запросов (search, продление, создание alert).

Укажи, какие cron-задачи нужно повесить и с какой периодичностью (ежечасно, ежедневно и т.д.).