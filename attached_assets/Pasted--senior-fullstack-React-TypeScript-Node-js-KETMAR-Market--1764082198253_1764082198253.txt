Ты — senior fullstack (React + TypeScript + Node.js) в проекте KETMAR Market.

Нужно реализовать ПОЛНЫЙ ФРОНТЕНД-ФУНКЦИОНАЛ, связанный с отложенными публикациями:

=========================================================
1. ФРОНТ: ВЫБОР ВРЕМЕНИ ПУБЛИКАЦИИ В МАСТЕРЕ ПОДАЧИ
=========================================================

Найди финальный шаг мастера подачи объявления (например `AdCreateFinalStep`, `PublishStep`, `ReviewStep` или аналог).  
Там нужно добавить блок “Когда опубликовать объявление”.

Сделать новый компонент:

`miniapp/src/components/schedule/SchedulePublishBlock.tsx`

API:

```ts
interface SchedulePublishBlockProps {
  publishAt: Date | null;
  onChange: (next: Date | null) => void;
}
Структура UI:

1.1. Переключатель (radio-кнопки)
scss
Копировать код
Когда опубликовать?

(●) Опубликовать сейчас
(○) Запланировать на позже
Если выбран вариант “Запланировать” — показываем date/time picker:

1.2. Дата + Время
Используем нативные <input type="datetime-local">,
или кастомный picker с модальным календарём (если у нас уже есть компоненты).

Требования:

минимальное время: через 5 минут от текущего (чтобы избежать случайных прошлых дат);

если пользователь пытается поставить прошлое время — подсветить красным + не давать подтвердить;

значение хранить в ISO-формате (new Date(value)).

1.3. Состояние
В мастере:

ts
Копировать код
const [publishAt, setPublishAt] = useState<Date | null>(null);
Перед отправкой на backend:

если publishAt === null → статус active,

если publishAt > now → статус scheduled.

1.4. Валидация
Если выбран режим “Запланировать”, но дата пустая → блокируем кнопку «Опубликовать».

Если всё заполнено → всё ок.

1.5. UI-подсказка
Под блоком:

Копировать код
ℹ️ Если вы выберете отложенную публикацию, объявление появится в поиске и ленте автоматически в указанное время.
Текст нейтральный, без ошибок.

=============================================================
2. ФРОНТ: МИНИ-АДМИНКА ДЛЯ ЗАПЛАНИРОВАННЫХ ПУБЛИКАЦИЙ
Нужно сделать экран для админов, где они видят:

список всех scheduled-объявлений,

время публикации,

статус (в очереди / скоро / опубликовано),

мини-график (кол-во публикаций в ближайшие часы/дни).

Создать новый экран:

miniapp/src/admin/ScheduledAdsScreen.tsx

Подключить его в админку (верхнее меню или скрытый route).

2.1. Запрос данных
Бэк должен отдавать:

GET /api/admin/scheduled-ads

Ответ:

json
Копировать код
[
  {
    "adId": "xxxxx",
    "title": "iPhone 15 Pro 256GB",
    "price": 2900,
    "publishAt": "2025-11-28T14:30:00.000Z",
    "owner": { "telegramId": 1234, "username": "seller123" },
    "createdAt": "...",
    "category": "electronics/smartphones"
  }
]
2.2. UI списка
Для каждого объявления:

Заголовок (название товара)

Цена

Время публикации: "28 ноября, 14:30"

До публикации: "через 3 часа 12 минут" (в реальном времени)

Кнопка «Открыть объявление»

Кнопка «Отменить» → вызывает PATCH /api/admin/scheduled-ads/:id/cancel

Стиль — как аккуратные карточки.

2.3. Мини-график публикаций (bar chart)
Сделать маленький график на ~3–5 дней вперёд:

Использовать мини-библиотеку:

Recharts
или

lightweight svg chart вручную.

Данные:

сгруппировать publishAt по дням,

вывести столбики: «Сколько объявлений выйдет в этот день».

Компонент:

miniapp/src/admin/components/ScheduleStatsChart.tsx

Передать в него массив:

ts
Копировать код
[{ date: '2025-11-28', count: 12 }, ...]
2.4. Цветовая маркировка
Если до публикации ≤ 1 час → подсветить карточку жёлтым.

Если ≤ 10 минут → слегка красноватым (предупреждение).

=============================================================
3. ПУШ-УВЕДОМЛЕНИЕ ПРОДАВЦУ: «Ваше объявление опубликовано»
Когда cron/worker активирует объявление (scheduled → active),
backend должен отправить в Telegram-продавцу уведомление.

Но твоя задача — ФРОНТ часть + интеграция со сторонами бота.

3.1. Что должно быть на фронте
Ничего сложного — просто предусмотреть, что в будущем
MiniApp может показывать пуши внутри WebApp через Telegram.WebApp.showPopup().

Добавить helper:

miniapp/src/utils/showPublishNotification.ts

ts
Копировать код
export function showPublishNotification(adTitle: string) {
  if (window.Telegram?.WebApp) {
    Telegram.WebApp.showPopup({
      title: "Объявление опубликовано",
      message: `Ваше объявление "${adTitle}" теперь видно покупателям.`,
      buttons: [{ id: "ok", type: "default", text: "Ок" }]
    });
  }
}
3.2. Где вызывать
Если MiniApp открыта в момент публикации,
бот может сделать callback через web_app_data событие.

Нужно добавить listener:

В главном файле MiniApp:

ts
Копировать код
Telegram.WebApp.onEvent("web_app_data", (data) => {
  try {
    const payload = JSON.parse(data.data);
    if (payload.type === "ad_published") {
       showPublishNotification(payload.title);
    }
  } catch (e) {}
});
3.3. Структура события от бота
Бот при публикации может отправить пользователю:

json
Копировать код
{
  "type": "ad_published",
  "adId": "xxxxx",
  "title": "iPhone 15 Pro"
}
И MiniApp покажет popup.

==========================================================
4. ХОРОШИЕ ПРАКТИКИ И ПРОВЕРКИ
На всех формах проверить:
если режим "Запланировать", но дата старше now — подсветить ошибку.

На вводе даты:

округлить секунды до нулей.

если выбранное время «слишком близко» (< 5 минут) — показывать подсказку:
"Минимум через 5 минут".

В админке:

добавить сортировку scheduled-объявлений по publishAt ASC.

добавить фильтр: "Сегодня / Завтра / На этой неделе / Все".

==========================================================
5. В КОНЦЕ — ОТЧЁТ
После выполнения:

ВЫВЕСТИ список изменённых файлов:

SchedulePublishBlock.tsx — блок выбора времени публикации.

AdCreateFinalStep.tsx — интеграция publishAt.

ScheduledAdsScreen.tsx — админ-экран со списком.

ScheduleStatsChart.tsx — график публикаций.

showPublishNotification.ts — popup для уведомления.

index.tsx — listener web_app_data.

Предложи ветку:

feature/scheduled-publish-frontend

И коммит:

feat(ui): add scheduled publish picker, admin scheduled list, and publish notifications