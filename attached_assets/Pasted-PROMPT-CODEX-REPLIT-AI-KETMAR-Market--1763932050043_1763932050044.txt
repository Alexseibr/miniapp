PROMPT ДЛЯ CODEX / REPLIT AI
Хочу, чтобы ты продолжил разработку проекта маркетплейса KETMAR Market в репозитории:

- GitHub: https://github.com/Alexseibr/miniapp
- Технологии уже есть: Node.js + Express + MongoDB + Telegraf + Vite (frontend).

Цель на этом этапе:
1) Сделать веб-интерфейс (MiniApp + обычный сайт) по визуалу и логике, похожий на Kufar.by.
2) Уточнить поведение по геолокации (город + расстояние до продавца).
3) Ориентироваться на то, что в будущем появятся мобильные приложения (React Native/Flutter), чтобы API был к этому готов.
4) Оставляем один общий Telegram-бот для всего маркетплейса, без отдельных нишевых ботов (но код надо сделать так, чтобы в будущем можно было легко добавить ниши).

---

## 1. ВАЖНЫЙ КОНТЕКСТ

### 1.1. Один общий бот

Сейчас нужен один основной Telegram-бот, который:
- даёт доступ к общему маркетплейсу;
- открывает MiniApp (WebApp) с общей витриной;
- дальше пользователь уже фильтрует по категориям/нишам внутри интерфейса.

Ниши (фермеры, ремесленники, аренда, авто, ярмарки и т.п.) — это:
- либо категории/подкатегории,
- либо “режимы” витрины (например, специальная страница “Ярмарка 8 марта”).

Пока **не делаем** кучу отдельных ботов.

### 1.2. Гео-логика “город + расстояние”

Важно:
- Покупатель должен видеть:
  - **город продавца**,
  - **расстояние до продавца** в метрах/километрах (например, “Минск, 850 м от вас”).
- НЕ показываем:
  - точный адрес,
  - улицу, дом.

Предполагается:
- У объявления есть:
  - `location` (lat, lng),
  - `city` (строка, название города). Если поля `city` ещё нет — нужно его добавить в модель Ad и во фронт.

Нужно:
1) На backend:
   - при выдаче объявлений добавить в API:
     - поле `city`,
     - при наличии координат пользователя (через query-параметры `lat` и `lng`) — вычислить расстояние и вернуть поле `distanceMeters` (число в метрах).
   - расчёт расстояния можно сделать через обычную формулу haversine.
2) На frontend:
   - в карточке объявления рядом с ценой/заголовком показывать что-то вроде:
     - `Минск • 1.2 км от вас`
   - если координат пользователя нет — просто показываем город, без расстояния.

### 1.3. Будущие мобильные приложения

Нужно спроектировать так, чтобы позже можно было:
- сделать мобильное приложение (React Native / Flutter),
- использовать те же REST эндпоинты.

Требования к API с учётом мобилки:
- Чёткие, стабильные эндпоинты (`/api/ads`, `/api/categories`, `/api/seasons`, `/api/orders`, `/api/users/me`).
- В ответах отдавать все нужные данные (город, расстояние, флаги доставки, статус, seasonCode и т.д.).
- Не завязывать фронт на “магические” поля — лучше явно описать интерфейс.

Мобильные приложения не пишем сейчас, просто API и frontend надо делать “чисто”.

---

## 2. ЗАДАЧИ ДЛЯ FRONTEND (VITE / REACT)

Считай, что backend и базовые модели уже реализованы (пользователи, категории, сезоны, объявления, заказы). Сейчас надо:

### 2.1. Главная страница витрины (как у Kufar)

Сделать стартовую страницу, которая:

1. Header:
   - логотип,
   - строка поиска,
   - кнопка/иконка перехода в Telegram-бот (например, "Открыть в Telegram").

2. Блок “Категории”:
   - плитка категорий (иконка + название),
   - категории берём из `/api/categories` — корневые категории.

3. Блок “Сезонные предложения”:
   - если есть активные сезоны из `/api/seasons` (`isActive = true`),
   - показать баннеры для активных сезонов (например, “Ярмарка 8 марта”).

4. Блок “Новые объявления”:
   - лента последних объявлений из `/api/ads?limit=20`,
   - для каждого объявления показываем:
     - фото (первое),
     - заголовок,
     - цену,
     - город + расстояние (если известны `lat/lng` пользователя),
     - иконки “доставка/самовывоз”.

Вёрстка:
- mobile-first,
- ориентироваться на простой, чистый стиль, примерно как у Kufar:
  - светлый фон,
  - карточки с тенью,
  - аккуратные отступы.

### 2.2. Страница категории/подкатегории

Для URL вида:
- `/category/:slug`
- `/category/:slug/:subslug`

Нужно:
- Подтянуть дерево категорий из `/api/categories`.
- Определить текущую категорию/подкатегорию по slug.
- Сверху показать:
  - название категории,
  - навигацию по подкатегориям (табы/плитки).
- Ниже — лента объявлений, подгружаемых из `/api/ads` с параметрами:
  - `categoryId`,
  - `subcategoryId` (если есть),
  - фильтры (цена, доставка, расстояние — можно пока сделать только базовый фильтр по цене).

### 2.3. Карточка объявления (страница детали)

Для URL `/ad/:id`:

- Запрос к `/api/ads/:id`.
- Показываем:
  - галерею фото,
  - цену,
  - заголовок,
  - описание,
  - город + расстояние,
  - основные характеристики (из `attributes`, для начала просто вывод key/value списком),
  - блок “Контакты”:
    - кнопка “Написать в Telegram” → ссылка `https://t.me/<username или прямой чат через tg://resolve>` (можно пока использовать username-заглушку или поле sellerTelegramId).
- Если поле `deliveryType` и `deliveryRadiusKm`:
  - показывать иконку “Доставка” и/или “Самовывоз”.

---

## 3. ДОРАБОТКИ BACKEND ПОД GEO + ГОРОД

Нужно доработать backend, чтобы фронту было удобно:

### 3.1. Модель Ad

Если в текущей модели `Ad` ещё нет поля `city` (строка) — добавить:

- `city: { type: String }`

Это строка, которую продавец или система задаёт при создании объявления (на данном этапе можно допустить, что она задаётся явно, позже — через геокодинг).

### 3.2. Расширить /api/ads

1. Поддержка query-параметров `lat` и `lng`:

- Если они переданы, для каждого объявления, у которого есть `location.lat` и `location.lng`, нужно:
  - посчитать расстояние в метрах до пользователя,
  - добавить в выдачу поле:
    - `distanceMeters: number`.

- Расстояние можно считать функцией haversine.

2. Формат ответа:

- По возможности не менять существующие поля,
- просто добавить:
  - `city`,
  - `distanceMeters` (если `lat/lng` были переданы).

3. Для списка объявлений:
- сортировку по distance пока можно **не** делать, но если просто, можно добавить опцию:
  - если переданы `lat/lng` и есть параметр `sortBy=distance`, то сортировать по расстоянию.

---

## 4. TELEGRAM-БОТ (ОДИН, ОБЩИЙ)

На этом этапе от бота нужно немного:

1. Команда `/start`:
   - отправить приветствие,
   - дать кнопки:
     - “Открыть маркетплейс” — кнопка WebApp с URL MiniApp (пока можно брать из переменной окружения `MINIAPP_URL` или из конфига).
2. В будущем через бота будет:
   - регистрация как продавца,
   - верификация телефона,
   - создание объявлений,
   - управление объявлениями.

Сейчас главное:
- не ломать текущую реализацию,
- убедиться, что логика с одним ботом и одной MiniApp корректна.

---

## 5. СВЯЗЬ С БУДУЩИМИ МОБИЛЬНЫМИ ПРИЛОЖЕНИЯМИ

При доработках учти:
- API должны быть пригодны для использования в мобилке:
  - `/api/ads` — список/фильтры,
  - `/api/ads/:id` — детали,
  - `/api/categories` — дерево категорий,
  - `/api/seasons` — сезоны,
  - `/api/orders` — заказы,
  - `/api/users/me` — профиль (можно оставить напозже).
- Не завязывать фронт на “хардкод” путей — использовать базовый URL и относительные маршруты.

---

## 6. ЧТО ИМЕННО СДЕЛАТЬ НА ЭТОМ ЭТАПЕ

1. Проверить структуру текущего проекта в репозитории `miniapp`:
   - backend (Express + Mongo + Telegraf),
   - frontend (Vite/React или другой стек).

2. Реализовать/доработать:
   - поле `city` в модели `Ad`,
   - логику расчёта `distanceMeters` в `/api/ads` при наличии `lat` и `lng`,
   - вернуть `city` и `distanceMeters` в ответах фронту.

3. На фронте (Vite/React):
   - главную страницу с:
     - плиткой категорий,
     - блоком сезонных ярмарок,
     - лентой новых объявлений с городом и расстоянием.
   - страницу категории/подкатегории.
   - страницу одного объявления.

4. Стиль:
   - делать визуал по духу похожим на Kufar:
     - карточки, список, фильтры,
     - чистый, простой UI, удобный для мобильника.
   - дизайн может быть упрощённым, главное — структура и логика.

5. Написать в README.md краткое описание:
   - как запускать backend,
   - как запускать frontend (Vite dev server),
   - какие основные эндпоинты есть,
   - как в браузере проверить, что всё работает.

Сделай, пожалуйста, все эти доработки последовательно и аккуратно, не ломая то, что уже есть в проекте. Если каких-то частей не хватает (например, нет фронта) — создай минимальный Vite/React frontend в этой же репе и подключи его к существующему backend.
