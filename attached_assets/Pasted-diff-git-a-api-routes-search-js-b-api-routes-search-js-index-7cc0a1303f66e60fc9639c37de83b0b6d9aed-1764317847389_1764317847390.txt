diff --git a/api/routes/search.js b/api/routes/search.js
index 7cc0a1303f66e60fc9639c37de83b0b6d9aed563..480328317a245a355d4919850676cff4f17d3524 100644
--- a/api/routes/search.js
+++ b/api/routes/search.js
@@ -1,35 +1,36 @@
 import express from 'express';
 import { Router } from 'express';
 import Ad from '../../models/Ad.js';
 import Category from '../../models/Category.js';
 import SearchLog from '../../models/SearchLog.js';
 import { haversineDistanceKm } from '../../utils/haversine.js';
 import HotSearchService from '../../services/HotSearchService.js';
 import SearchAlertService from '../../services/SearchAlertService.js';
 import DemandNotificationService from '../../services/DemandNotificationService.js';
 import FastMarketScoringService from '../../services/FastMarketScoringService.js';
+import SellerProfile from '../../models/SellerProfile.js';
 
 const router = Router();
 const DEFAULT_LIMIT = 100;
 const FETCH_LIMIT = 500;
 
 let hiddenCategorySlugsCache = null;
 let hiddenCategoryCacheTime = 0;
 const HIDDEN_CATEGORY_CACHE_DURATION = 5 * 60 * 1000;
 
 async function getHiddenCategorySlugs() {
   const now = Date.now();
   if (hiddenCategorySlugsCache && (now - hiddenCategoryCacheTime) < HIDDEN_CATEGORY_CACHE_DURATION) {
     return hiddenCategorySlugsCache;
   }
   
   try {
     const hiddenCategories = await Category.find({ visible: false }, { slug: 1 }).lean();
     hiddenCategorySlugsCache = hiddenCategories.map(c => c.slug);
     hiddenCategoryCacheTime = now;
     return hiddenCategorySlugsCache;
   } catch (error) {
     console.error('Error fetching hidden categories:', error);
     return hiddenCategorySlugsCache || [];
   }
 }
@@ -93,98 +94,132 @@ function sortItems(items, sortKey, hasGeoContext) {
     case 'smart':
       return sorted.sort((a, b) => (b.fastMarketScore ?? 0) - (a.fastMarketScore ?? 0));
     case 'newest':
     default:
       return sorted.sort(
         (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
       );
   }
 }
 
 router.get('/search', async (req, res) => {
   try {
     console.log('[Search] Request:', req.query);
     
     const {
       q,
       categoryId,
       subcategoryId,
       seasonCode,
       lat,
       lng,
       maxDistanceKm,
       minPrice,
       maxPrice,
       sort = 'newest',
+      onlyWithDelivery,
       limit,
     } = req.query;
 
     const limitNumber = Math.min(parseNumber(limit) || DEFAULT_LIMIT, DEFAULT_LIMIT);
 
     const baseQuery = {
       status: 'active',
       moderationStatus: 'approved',
     };
 
     // –ü–æ–ª—É—á–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
     const hiddenSlugs = await getHiddenCategorySlugs();
     
     // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ —Å–∫—Ä—ã—Ç—ã
     if (categoryId && hiddenSlugs.includes(categoryId)) {
       return res.json([]);
     }
     if (subcategoryId && hiddenSlugs.includes(subcategoryId)) {
       return res.json([]);
     }
     
     if (categoryId) baseQuery.categoryId = categoryId;
     if (subcategoryId) baseQuery.subcategoryId = subcategoryId;
     if (seasonCode) baseQuery.seasonCode = seasonCode;
 
     // –ò—Å–∫–ª—é—á–∞–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∏–∑ —Å–∫—Ä—ã—Ç—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π (–±—ã—Å—Ç—Ä—ã–π –º–∞—Ä–∫–µ—Ç)
     // –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
     if (!categoryId && !subcategoryId && hiddenSlugs.length > 0) {
       baseQuery.$and = [
         { categoryId: { $nin: hiddenSlugs } },
         { subcategoryId: { $nin: hiddenSlugs } },
       ];
     }
 
     const minPriceNumber = parseNumber(minPrice);
     const maxPriceNumber = parseNumber(maxPrice);
     if (minPriceNumber != null && Number.isFinite(minPriceNumber)) {
       baseQuery.price = { ...baseQuery.price, $gte: minPriceNumber };
     }
     if (maxPriceNumber != null && Number.isFinite(maxPriceNumber)) {
       baseQuery.price = { ...baseQuery.price, $lte: maxPriceNumber };
     }
 
+    if (onlyWithDelivery === 'true' || onlyWithDelivery === true) {
+      baseQuery.hasDelivery = true;
+      baseQuery.$or = [
+        ...(baseQuery.$or || []),
+        { storeId: { $ne: null } },
+        { shopProfileId: { $ne: null } },
+      ];
+    }
+
     const ads = await Ad.find(baseQuery).sort({ createdAt: -1 }).limit(FETCH_LIMIT).lean();
 
     const regex = q ? new RegExp(q, 'i') : null;
     let filtered = regex ? ads.filter((ad) => matchesQuery(ad, regex)) : ads;
 
+    if (onlyWithDelivery === 'true' || onlyWithDelivery === true) {
+      const storeIds = filtered
+        .map((ad) => ad.storeId || ad.shopProfileId)
+        .filter(Boolean);
+      const uniqueStoreIds = [...new Set(storeIds.map((id) => id.toString()))];
+
+      if (uniqueStoreIds.length > 0) {
+        const stores = await SellerProfile.find({
+          _id: { $in: uniqueStoreIds },
+          canDeliver: true,
+        })
+          .select('_id canDeliver')
+          .lean();
+
+        const deliverableStores = new Set(stores.map((s) => s._id.toString()));
+        filtered = filtered.filter((ad) => {
+          const storeId = ad.storeId || ad.shopProfileId;
+          return storeId && deliverableStores.has(storeId.toString()) && ad.hasDelivery === true;
+        });
+      } else {
+        filtered = [];
+      }
+    }
+
     const latNumber = parseNumber(lat);
     const lngNumber = parseNumber(lng);
     const hasGeo = Number.isFinite(latNumber) && Number.isFinite(lngNumber);
     const maxDistanceNumber = parseNumber(maxDistanceKm);
 
     if (hasGeo) {
       filtered = filtered
         .map((ad) => {
           if (!ad.location || ad.location.lat == null || ad.location.lng == null) {
             return null;
           }
 
           const distanceKm = haversineDistanceKm(
             latNumber,
             lngNumber,
             Number(ad.location.lat),
             Number(ad.location.lng)
           );
 
           if (distanceKm == null) {
             return null;
           }
 
           const roundedDistance = Number(distanceKm.toFixed(2));
           if (
diff --git a/api/routes/seller-profile.js b/api/routes/seller-profile.js
index 8c36bbae28cb77fc7c2aefc8b206a32302949322..e584d3ffcc2386a5a0d592db0fc528a455f6f63d 100644
--- a/api/routes/seller-profile.js
+++ b/api/routes/seller-profile.js
@@ -22,124 +22,138 @@ router.post('/', authMiddleware, async (req, res) => {
     if (existing) {
       return res.status(400).json({
         success: false,
         error: 'seller_exists',
         message: '–ú–∞–≥–∞–∑–∏–Ω —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç',
         profile: existing,
       });
     }
     
     const {
       name,
       avatar,
       banner,
       description,
       isFarmer,
       phone,
       instagram,
       telegramUsername,
       address,
       geo,
       city,
       cityCode,
       workingHours,
       deliveryInfo,
       tags,
+      role,
+      canDeliver,
+      deliveryRadiusKm,
+      defaultDeliveryPrice,
+      verificationLevel,
+      baseLocation,
     } = req.body;
     
     if (!name || name.trim().length < 2) {
       return res.status(400).json({
         success: false,
         error: 'invalid_name',
         message: '–ù–∞–∑–≤–∞–Ω–∏–µ –º–∞–≥–∞–∑–∏–Ω–∞ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞',
       });
     }
     
     const slug = await SellerProfile.generateSlug(name);
     
     const profile = new SellerProfile({
       userId: user._id,
       telegramId: user.telegramId,
       slug,
       name: name.trim(),
       avatar,
       banner,
       description: description?.trim(),
       isFarmer: Boolean(isFarmer),
       phone: phone || user.phone,
       instagram,
       telegramUsername: telegramUsername || user.username,
       address,
       geo: geo ? {
         type: 'Point',
         coordinates: [geo.lng || geo.coordinates?.[0], geo.lat || geo.coordinates?.[1]],
       } : null,
       city,
       cityCode,
       workingHours,
       deliveryInfo,
       tags: tags || [],
+      role: role || 'SHOP',
+      canDeliver: Boolean(canDeliver),
+      deliveryRadiusKm: deliveryRadiusKm ?? null,
+      defaultDeliveryPrice: defaultDeliveryPrice ?? null,
+      verificationLevel: verificationLevel || null,
+      baseLocation: baseLocation || undefined,
     });
     
     await profile.save();
     await profile.updateProductsCount();
     
     console.log(`[SellerProfile] Created store "${name}" for user ${user.telegramId}`);
     
     res.status(201).json({
       success: true,
       profile,
     });
   } catch (error) {
     console.error('[SellerProfile] Create error:', error);
     res.status(500).json({
       success: false,
       error: 'server_error',
       message: '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –º–∞–≥–∞–∑–∏–Ω–∞',
     });
   }
 });
 
 router.put('/', authMiddleware, async (req, res) => {
   try {
     const user = req.currentUser;
     
     const profile = await SellerProfile.findOne({ userId: user._id });
     
     if (!profile) {
       return res.status(404).json({
         success: false,
         error: 'not_found',
         message: '–ú–∞–≥–∞–∑–∏–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω',
       });
     }
     
     const allowedFields = [
       'name', 'avatar', 'banner', 'description', 'isFarmer',
       'phone', 'instagram', 'telegramUsername', 'address',
-      'city', 'cityCode', 'region', 'workingHours', 'deliveryInfo', 
-      'showPhone', 'tags',
+      'city', 'cityCode', 'region', 'workingHours', 'deliveryInfo',
+      'showPhone', 'tags', 'role', 'canDeliver', 'deliveryRadiusKm',
+      'defaultDeliveryPrice', 'verificationLevel', 'baseLocation',
+      'isVerified',
     ];
     
     for (const field of allowedFields) {
       if (req.body[field] !== undefined) {
         profile[field] = req.body[field];
       }
     }
     
     if (req.body.geo) {
       profile.geo = {
         type: 'Point',
         coordinates: [
           req.body.geo.lng || req.body.geo.coordinates?.[0],
           req.body.geo.lat || req.body.geo.coordinates?.[1],
         ],
       };
     }
     
     if (req.body.name && req.body.name !== profile.name) {
       profile.slug = await SellerProfile.generateSlug(req.body.name);
     }
     
     await profile.save();
     
     console.log(`[SellerProfile] Updated store "${profile.name}"`);
diff --git a/api/routes/shop-orders.js b/api/routes/shop-orders.js
new file mode 100644
index 0000000000000000000000000000000000000000..e5f9c234a8ed8f67202d5a9ee91b53b4a9cec841
--- /dev/null
+++ b/api/routes/shop-orders.js
@@ -0,0 +1,202 @@
+import { Router } from 'express';
+import { authMiddleware } from '../../middleware/auth.js';
+import Order from '../../models/Order.js';
+import Ad from '../../models/Ad.js';
+import SellerProfile from '../../models/SellerProfile.js';
+import { haversineDistanceKm } from '../../utils/haversine.js';
+
+const router = Router();
+
+function resolveDateRange(filter) {
+  const todayStart = new Date();
+  todayStart.setHours(0, 0, 0, 0);
+  const tomorrowStart = new Date(todayStart);
+  tomorrowStart.setDate(tomorrowStart.getDate() + 1);
+  const dayAfterTomorrow = new Date(tomorrowStart);
+  dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);
+
+  if (filter === 'tomorrow') {
+    return { $gte: tomorrowStart, $lt: dayAfterTomorrow };
+  }
+  if (filter === 'future') {
+    return { $gte: dayAfterTomorrow };
+  }
+  return { $gte: todayStart, $lt: tomorrowStart };
+}
+
+function normalizeQuantity(value) {
+  const parsed = Number(value);
+  if (!Number.isFinite(parsed) || parsed <= 0) return 1;
+  return Math.floor(parsed);
+}
+
+router.post('/', authMiddleware, async (req, res) => {
+  try {
+    const user = req.currentUser;
+    const {
+      adId,
+      quantity = 1,
+      deliveryRequired = false,
+      deliveryAddress,
+      deliveryLocation,
+      scheduledDate,
+    } = req.body || {};
+
+    if (!adId) {
+      return res.status(400).json({ message: 'adId –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' });
+    }
+
+    const ad = await Ad.findById(adId);
+    if (!ad) {
+      return res.status(404).json({ message: '–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω' });
+    }
+
+    const sellerProfile = await SellerProfile.findOne({ telegramId: ad.sellerTelegramId });
+    if (!sellerProfile) {
+      return res.status(400).json({ message: '–£ —Ç–æ–≤–∞—Ä–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å –ø—Ä–æ–¥–∞–≤—Ü–∞' });
+    }
+
+    if (deliveryRequired) {
+      const deliveryEnabled = ad.hasDelivery === true && sellerProfile.canDeliver === true;
+      if (!deliveryEnabled) {
+        return res.status(400).json({ message: '–î–æ—Å—Ç–∞–≤–∫–∞ –¥–ª—è —ç—Ç–æ–≥–æ —Ç–æ–≤–∞—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞' });
+      }
+      if (deliveryLocation) {
+        const lat = Number(deliveryLocation.lat);
+        const lng = Number(deliveryLocation.lng);
+        if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
+          return res.status(400).json({ message: '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–æ—Å—Ç–∞–≤–∫–∏' });
+        }
+      }
+    }
+
+    const safeQuantity = normalizeQuantity(quantity);
+
+    if (ad.maxDailyQuantity != null) {
+      const available = ad.availableQuantity != null ? ad.availableQuantity : ad.maxDailyQuantity;
+      if (available == null || available < safeQuantity) {
+        return res.status(400).json({ message: '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É' });
+      }
+      ad.availableQuantity = available - safeQuantity;
+      await ad.save();
+    }
+
+    const scheduled = scheduledDate ? new Date(scheduledDate) : new Date();
+
+    const order = await Order.create({
+      adId: ad._id,
+      sellerId: sellerProfile.userId,
+      sellerTelegramId: ad.sellerTelegramId,
+      shopProfileId: sellerProfile._id,
+      user: user?._id,
+      buyerId: user?._id || null,
+      buyerTelegramId: user.telegramId,
+      buyerName: user.firstName,
+      buyerUsername: user.username,
+      items: [
+        {
+          adId: ad._id,
+          title: ad.title,
+          quantity: safeQuantity,
+          price: ad.price,
+          currency: ad.currency,
+          sellerTelegramId: ad.sellerTelegramId,
+        },
+      ],
+      totalPrice: (ad.price || 0) * safeQuantity,
+      status: 'NEW',
+      deliveryRequired: Boolean(deliveryRequired),
+      deliveryAddress,
+      deliveryLocation: deliveryLocation && deliveryLocation.lat != null && deliveryLocation.lng != null
+        ? { lat: Number(deliveryLocation.lat), lng: Number(deliveryLocation.lng) }
+        : undefined,
+      scheduledDate: Number.isFinite(new Date(scheduled).getTime()) ? scheduled : new Date(),
+    });
+
+    return res.status(201).json({ success: true, order });
+  } catch (error) {
+    console.error('[ShopOrders] create error', error);
+    return res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫–∞–∑–∞' });
+  }
+});
+
+router.get('/', authMiddleware, async (req, res) => {
+  try {
+    const user = req.currentUser;
+    const { date = 'today' } = req.query;
+    const profile = await SellerProfile.findOne({ userId: user._id });
+
+    if (!profile) {
+      return res.json({ items: [] });
+    }
+
+    const range = resolveDateRange(String(date));
+    const query = {
+      shopProfileId: profile._id,
+      scheduledDate: range,
+    };
+
+    const items = await Order.find(query)
+      .sort({ scheduledDate: 1, createdAt: -1 })
+      .lean();
+
+    return res.json({ items });
+  } catch (error) {
+    console.error('[ShopOrders] list error', error);
+    return res.status(500).json({ message: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–∫–∞–∑–æ–≤' });
+  }
+});
+
+router.get('/route-plan', authMiddleware, async (req, res) => {
+  try {
+    const user = req.currentUser;
+    const { date = 'today' } = req.query;
+    const profile = await SellerProfile.findOne({ userId: user._id });
+
+    if (!profile || !profile.baseLocation?.lat || !profile.baseLocation?.lng) {
+      return res.status(400).json({ message: '–ù–µ –∑–∞–¥–∞–Ω–∞ —Å—Ç–∞—Ä—Ç–æ–≤–∞—è —Ç–æ—á–∫–∞ –º–∞—Ä—à—Ä—É—Ç–∞' });
+    }
+
+    const range = resolveDateRange(String(date));
+    const activeStatuses = ['NEW', 'CONFIRMED', 'new', 'processed'];
+
+    const orders = await Order.find({
+      shopProfileId: profile._id,
+      scheduledDate: range,
+      deliveryRequired: true,
+      status: { $in: activeStatuses },
+    }).lean();
+
+    let currentPoint = { lat: Number(profile.baseLocation.lat), lng: Number(profile.baseLocation.lng) };
+    const remaining = [...orders];
+    const sorted = [];
+
+    while (remaining.length > 0) {
+      let nearestIndex = 0;
+      let nearestDistance = Infinity;
+
+      remaining.forEach((order, index) => {
+        const lat = order.deliveryLocation?.lat;
+        const lng = order.deliveryLocation?.lng;
+        const distance = haversineDistanceKm(currentPoint.lat, currentPoint.lng, Number(lat), Number(lng));
+        if (distance != null && distance < nearestDistance) {
+          nearestDistance = distance;
+          nearestIndex = index;
+        }
+      });
+
+      const [nextOrder] = remaining.splice(nearestIndex, 1);
+      sorted.push({ ...nextOrder, distanceKmFromPrev: nearestDistance });
+      if (nextOrder.deliveryLocation?.lat != null && nextOrder.deliveryLocation?.lng != null) {
+        currentPoint = { lat: Number(nextOrder.deliveryLocation.lat), lng: Number(nextOrder.deliveryLocation.lng) };
+      }
+    }
+
+    return res.json({ items: sorted });
+  } catch (error) {
+    console.error('[ShopOrders] route plan error', error);
+    return res.status(500).json({ message: '–û—à–∏–±–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞' });
+  }
+});
+
+export default router;
diff --git a/api/server.js b/api/server.js
index a3e488ba68d6f8c0f830dd0cfd5819dcfa339b03..30b0ca3e323f531f97b3deb8eb0d915bdac2a2bb 100644
--- a/api/server.js
+++ b/api/server.js
@@ -26,50 +26,51 @@ import uploadsRoutes from './routes/uploads.js';
 import mediaRoutes from './routes/media.js';
 import geoRoutes from './routes/geo.js';
 import pricingRoutes from './routes/pricing.js';
 import farmerRoutes from './routes/farmer.js';
 import farmerSubscriptionsRoutes from './routes/farmer-subscriptions.js';
 import globalSearchRoutes from './routes/globalSearch.js';
 import trendsRoutes from './routes/trends.js';
 import aiRoutes from './routes/ai.js';
 import recommendationsRoutes from './routes/recommendations.js';
 import geoIntelligenceRoutes from './routes/geoIntelligence.js';
 import sellerProfileRoutes from './routes/seller-profile.js';
 import sellerSubscriptionsRoutes from './routes/seller-subscriptions.js';
 import sellerReviewsRoutes from './routes/seller-reviews.js';
 import sellerAnalyticsRoutes from './routes/seller-analytics.js';
 import twinRoutes from './routes/twin.js';
 import dynamicPriceRoutes from './routes/dynamicPrice.js';
 import sellerTwinRoutes from './routes/sellerTwin.js';
 import queuesRoutes from './routes/queues.js';
 import feedRoutes from './routes/feed.js';
 import autoCategorizationRoutes from './routes/autoCategorization.js';
 import storeProAnalyticsRoutes from './routes/store-pro-analytics.js';
 import campaignAnalyticsRoutes from './routes/campaign-analytics.js';
 import ratingRoutes from './routes/rating.js';
 import adminRatingRoutes from './routes/admin-rating.js';
 import devicesRoutes from './routes/devices.js';
+import shopOrdersRoutes from './routes/shop-orders.js';
 
 const app = express();
 
 // Compression middleware (gzip)
 app.use(compression({
   filter: (req, res) => {
     if (req.headers['x-no-compression']) {
       return false;
     }
     return compression.filter(req, res);
   },
   threshold: 1024,
   level: 6,
 }));
 
 // Middleware
 app.use(express.json());
 app.use(express.urlencoded({ extended: true }));
 
 // –ë–∞–∑–æ–≤—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã
 app.get('/api', (_req, res) => {
   res.json({
     message: 'KETMAR API',
     version: '1.0.0',
     endpoints: {
@@ -96,50 +97,51 @@ app.get('/health', (_req, res) => {
   res.json({
     status: 'ok',
     timestamp: new Date().toISOString(),
   });
 });
 
 // API –º–∞—Ä—à—Ä—É—Ç—ã
 app.use('/api/users', userRoutes);
 app.use('/api/favorites', miniAppFavoriteRoutes);
 app.use('/api/orders', miniAppOrderRoutes);
 app.use('/api/ads', adsRoutes);
 app.use('/api/ads', adsSearchRoutes);
 app.use('/api/categories', categoriesRoutes);
 app.use('/api/seasons', seasonsRoutes);
 app.use('/api/subscriptions', subscriptionsRoutes);
 app.use('/api/orders', telegramAuthMiddleware, ordersRoutes);
 app.use('/api/mod', telegramAuthMiddleware, moderationRoutes);
 // Public admin auth endpoints (NOT protected by adminAuth)
 app.use('/api/admin/auth', adminAuthRoutes);
 // Protected admin endpoints
 app.use('/api/admin', adminAuth, adminRoutes);
 app.use('/api/layout', layoutRoutes);
 app.use('/api/content', contentRoutes);
 app.use('/auth', authRoutes);
 app.use('/api/auth', phoneAuthRoutes);
+app.use('/api/shop/orders', shopOrdersRoutes);
 app.use('/api/chat', chatRoutes);
 app.use('/api/uploads', uploadsRoutes);
 app.use('/api/media', mediaRoutes);
 app.use('/api/geo', geoRoutes);
 app.use('/api/pricing', pricingRoutes);
 app.use('/api/farmer', farmerRoutes);
 app.use('/api/farmer/subscriptions', farmerSubscriptionsRoutes);
 app.use('/api/search', globalSearchRoutes);
 app.use('/api/trends', trendsRoutes);
 app.use('/api/ai', aiRoutes);
 app.use('/api/recommendations', recommendationsRoutes);
 app.use('/api/geo-intelligence', geoIntelligenceRoutes);
 app.use('/api/seller-profile', sellerProfileRoutes);
 app.use('/api/seller/subscribe', sellerSubscriptionsRoutes);
 app.use('/api/seller', sellerReviewsRoutes);
 app.use('/api/seller-analytics', sellerAnalyticsRoutes);
 app.use('/api/twin', twinRoutes);
 app.use('/api/dynamic-price', dynamicPriceRoutes);
 app.use('/api/seller-twin', sellerTwinRoutes);
 app.use('/api/queues', queuesRoutes);
 app.use('/api/feed', feedRoutes);
 app.use('/api/auto-categorize', autoCategorizationRoutes);
 app.use('/api/store/pro-analytics', storeProAnalyticsRoutes);
 app.use('/api/campaign-analytics', campaignAnalyticsRoutes);
 app.use('/api/campaigns', campaignAnalyticsRoutes);
diff --git a/middleware/validateCreateAd.js b/middleware/validateCreateAd.js
index 401ba99a922dbef8f743ba84030cff9b81688b85..3ee740caa410453c4637a726b5f3e46ed535ddf2 100644
--- a/middleware/validateCreateAd.js
+++ b/middleware/validateCreateAd.js
@@ -1,26 +1,27 @@
 import Season from '../models/Season.js';
+import SellerProfile from '../models/SellerProfile.js';
 
 const ALLOWED_DELIVERY_TYPES = ['pickup_only', 'delivery_only', 'delivery_and_pickup'];
 const CATEGORY_DEFAULT_LIFETIME = {
   berries: 3,
   berries_fresh: 3,
   flowers: 3,
   flowers_tulips: 3,
   tulips_single: 3,
   tulips_bouquets: 3,
   farm: 3,
   craft: 7,
   cakes: 7,
   bakery: 7,
   eclairs: 7,
   artisans: 7,
   services: 14,
   service: 14,
   real_estate: 30,
   apartments: 30,
   housing: 30,
   auto: 30,
   cars: 30,
 };
 const DEFAULT_LIFETIME_DAYS = 7;
 const MAX_LIFETIME_DAYS = 30;
@@ -90,74 +91,97 @@ async function validateCreateAd(req, res, next) {
 
     const title = normalizeString(payload.title);
     if (!title || title.length < 3 || title.length > 120) {
       return res.status(400).json({ error: '–ü–æ–ª–µ title –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ (3-120 —Å–∏–º–≤–æ–ª–æ–≤)' });
     }
 
     const categoryId = normalizeSlug(payload.categoryId);
     if (!categoryId) {
       return res.status(400).json({ error: '–ü–æ–ª–µ categoryId –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ' });
     }
 
     const subcategoryId = normalizeSlug(payload.subcategoryId);
     if (!subcategoryId) {
       return res.status(400).json({ error: '–ü–æ–ª–µ subcategoryId –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ' });
     }
 
     const price = parsePositiveNumber(payload.price);
     if (!price) {
       return res.status(400).json({ error: '–ü–æ–ª–µ price –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º' });
     }
 
     const sellerTelegramId = parsePositiveNumber(payload.sellerTelegramId);
     if (!sellerTelegramId) {
       return res.status(400).json({ error: '–ü–æ–ª–µ sellerTelegramId –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ' });
     }
+    const sellerProfile = await SellerProfile.findOne({ telegramId: sellerTelegramId }).lean();
 
     let deliveryType = null;
     if (payload.deliveryType != null) {
       const normalizedDeliveryType = payload.deliveryType;
       if (!ALLOWED_DELIVERY_TYPES.includes(normalizedDeliveryType)) {
         return res.status(400).json({ error: 'deliveryType –∏–º–µ–µ—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ' });
       }
       deliveryType = normalizedDeliveryType;
     }
 
     let deliveryRadiusKm = null;
     if (deliveryType && deliveryType.includes('delivery')) {
       deliveryRadiusKm = parsePositiveNumber(payload.deliveryRadiusKm);
       if (!deliveryRadiusKm) {
         return res.status(400).json({ error: 'deliveryRadiusKm –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏' });
       }
     } else if (payload.deliveryRadiusKm != null) {
       const parsedRadius = parsePositiveNumber(payload.deliveryRadiusKm);
       if (!parsedRadius) {
         return res.status(400).json({ error: 'deliveryRadiusKm –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º' });
       }
       deliveryRadiusKm = parsedRadius;
     }
 
+    const wantsDelivery = Boolean(payload.hasDelivery);
+    if (wantsDelivery && (!sellerProfile || !sellerProfile.canDeliver)) {
+      return res.status(400).json({ error: '–î–æ—Å—Ç–∞–≤–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –ø—Ä–æ–¥–∞–≤—Ü–∞–º —Å –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –º–∞–≥–∞–∑–∏–Ω–æ–º' });
+    }
+
+    const deliveryPriceOverride = payload.deliveryPriceOverride != null
+      ? Number(payload.deliveryPriceOverride)
+      : null;
+    if (deliveryPriceOverride != null && (!Number.isFinite(deliveryPriceOverride) || deliveryPriceOverride < 0)) {
+      return res.status(400).json({ error: 'deliveryPriceOverride –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º' });
+    }
+
+    const maxDailyQuantity = payload.maxDailyQuantity != null ? Number(payload.maxDailyQuantity) : null;
+    if (maxDailyQuantity != null && (!Number.isFinite(maxDailyQuantity) || maxDailyQuantity < 0)) {
+      return res.status(400).json({ error: 'maxDailyQuantity –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º' });
+    }
+
+    const availableQuantity = payload.availableQuantity != null ? Number(payload.availableQuantity) : null;
+    if (availableQuantity != null && (!Number.isFinite(availableQuantity) || availableQuantity < 0)) {
+      return res.status(400).json({ error: 'availableQuantity –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º' });
+    }
+
     let attributes = {};
     if (payload.attributes != null) {
       if (!isPlainObject(payload.attributes)) {
         return res.status(400).json({ error: 'attributes –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–±—ä–µ–∫—Ç–æ–º' });
       }
       attributes = { ...payload.attributes };
     }
 
     let location = undefined;
     if (payload.location != null) {
       if (!isPlainObject(payload.location)) {
         return res.status(400).json({ error: 'location –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–±—ä–µ–∫—Ç–æ–º' });
       }
       const lat = Number(payload.location.lat);
       const lng = Number(payload.location.lng);
       if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
         return res.status(400).json({ error: 'location.lat –∏ location.lng –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' });
       }
       location = { lat, lng };
     }
 
     const photos = Array.isArray(payload.photos)
       ? payload.photos
           .filter((photo) => typeof photo === 'string' && photo.trim())
           .map((photo) => photo.trim())
@@ -212,50 +236,60 @@ async function validateCreateAd(req, res, next) {
       }
     }
 
     const baseDate = publishAt || new Date();
     const adjustedValidUntil = calculateValidUntil(baseDate, lifetimeDays);
 
     const sanitized = {
       title,
       description: normalizeString(payload.description),
       categoryId,
       subcategoryId,
       price,
       currency: normalizeString(payload.currency) || 'RUB',
       photos,
       previewUrl,
       attributes,
       sellerTelegramId,
       city: payload.city ? normalizeString(payload.city) : null,
       geoLabel: payload.geoLabel ? normalizeString(payload.geoLabel) : null,
       contactType,
       contactPhone: payload.contactPhone ? normalizeString(payload.contactPhone) : null,
       contactUsername: payload.contactUsername ? normalizeString(payload.contactUsername) : null,
       contactInstagram: payload.contactInstagram ? normalizeString(payload.contactInstagram) : null,
       deliveryType,
       deliveryRadiusKm,
+      hasDelivery: wantsDelivery,
+      deliveryPriceOverride,
+      maxDailyQuantity: maxDailyQuantity != null ? maxDailyQuantity : undefined,
+      availableQuantity: availableQuantity != null
+        ? availableQuantity
+        : maxDailyQuantity != null
+          ? maxDailyQuantity
+          : undefined,
+      storeId: sellerProfile?._id,
+      shopProfileId: sellerProfile?._id,
       location,
       seasonCode,
       lifetimeDays,
       validUntil: adjustedValidUntil,
       moderationStatus: publishAt ? 'scheduled' : 'approved',
       status: publishAt ? 'scheduled' : 'active',
       publishAt,
       deliveryOptions: Array.isArray(payload.deliveryOptions)
         ? payload.deliveryOptions.filter((option) => typeof option === 'string' && option.trim())
         : undefined,
       isLiveSpot: Boolean(payload.isLiveSpot),
     };
 
     // Remove undefined optional fields
     if (!sanitized.deliveryType) {
       delete sanitized.deliveryType;
     }
     if (!sanitized.deliveryRadiusKm && sanitized.deliveryRadiusKm !== 0) {
       delete sanitized.deliveryRadiusKm;
     }
     if (!sanitized.location) {
       delete sanitized.location;
     }
     if (!sanitized.seasonCode) {
       delete sanitized.seasonCode;
diff --git a/miniapp/src/pages/SearchResultsPage.tsx b/miniapp/src/pages/SearchResultsPage.tsx
index 79725834748395c99d53245ff94d95c9bbf0326c..d4d729a77d45ff1c0795cc48785e910863057847 100644
--- a/miniapp/src/pages/SearchResultsPage.tsx
+++ b/miniapp/src/pages/SearchResultsPage.tsx
@@ -1,153 +1,158 @@
 import { useState, useEffect, useMemo } from 'react';
 import { useNavigate, useSearchParams } from 'react-router-dom';
 import { ArrowLeft, Search, X, SlidersHorizontal, ChevronDown } from 'lucide-react';
 import { useGeo } from '@/utils/geo';
 import { getThumbnailUrl, NO_PHOTO_PLACEHOLDER } from '@/constants/placeholders';
 import { DistanceBadge } from '@/components/DistanceBadge';
 
 interface Ad {
   _id: string;
   title: string;
   description?: string;
   price?: number;
   photos?: string[];
   distanceKm?: number;
   createdAt: string;
   categoryId?: string;
   subcategoryId?: string;
+  hasDelivery?: boolean;
 }
 
 interface FilterChip {
   id: string;
   label: string;
   active: boolean;
 }
 
 const RADIUS_OPTIONS = [
   { value: 5, label: '5 –∫–º' },
   { value: 10, label: '10 –∫–º' },
   { value: 30, label: '30 –∫–º' },
   { value: 50, label: '50 –∫–º' },
   { value: 100, label: '100 –∫–º' },
   { value: 500, label: '–í—Å—è —Å—Ç—Ä–∞–Ω–∞' },
 ];
 
 const SORT_OPTIONS = [
   { value: 'newest', label: '–ü–æ –¥–∞—Ç–µ' },
   { value: 'distance', label: '–ü–æ —É–¥–∞–ª–µ–Ω–∏—é' },
   { value: 'price_asc', label: '–°–Ω–∞—á–∞–ª–∞ –¥–µ—à—ë–≤—ã–µ' },
   { value: 'price_desc', label: '–°–Ω–∞—á–∞–ª–∞ –¥–æ—Ä–æ–≥–∏–µ' },
 ];
 
 export default function SearchResultsPage() {
   const navigate = useNavigate();
   const [searchParams] = useSearchParams();
   const query = searchParams.get('q') || '';
   
   const { coords, radiusKm, status: geoStatus, requestLocation, cityName } = useGeo();
   
   // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ useGeo –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç –ú–∏–Ω—Å–∫
   const userLat = coords?.lat || 53.9;
   const userLng = coords?.lng || 27.5667;
   const hasLocation = !!coords;
   
   const [searchText, setSearchText] = useState(query);
   const [ads, setAds] = useState<Ad[]>([]);
   const [loading, setLoading] = useState(true);
   const [totalCount, setTotalCount] = useState(0);
   const [selectedRadius, setSelectedRadius] = useState(radiusKm || 100);
   const [sortBy, setSortBy] = useState('distance');
   const [showSortSheet, setShowSortSheet] = useState(false);
   const [activeFilter, setActiveFilter] = useState('all');
+  const [onlyWithDelivery, setOnlyWithDelivery] = useState(false);
   
   const filterChips: FilterChip[] = useMemo(() => {
     const chips: FilterChip[] = [
       { id: 'all', label: '–í—Å—ë', active: activeFilter === 'all' },
       { id: 'farmer', label: '–§–µ—Ä–º–µ—Ä—Å–∫–∏–µ —Ç–æ–≤–∞—Ä—ã', active: activeFilter === 'farmer' },
       { id: 'fresh', label: '–°–≤–µ–∂–∏–µ', active: activeFilter === 'fresh' },
       { id: 'today', label: '–°–µ–≥–æ–¥–Ω—è', active: activeFilter === 'today' },
     ];
     return chips;
   }, [activeFilter]);
 
   useEffect(() => {
     if (!query) return;
     
     const fetchResults = async () => {
       setLoading(true);
       try {
         console.log('üîç –ü–æ–∏—Å–∫:', query);
         console.log('üìç –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã:', { lat: userLat, lng: userLng, hasLocation, cityName });
         console.log('üìè –†–∞–¥–∏—É—Å:', selectedRadius, '–∫–º');
         
         const params = new URLSearchParams({
           query: query,
           lat: String(userLat),
           lng: String(userLng),
           radiusKm: String(selectedRadius),
           sort: sortBy === 'newest' ? 'date' : sortBy,
           limit: '50',
         });
+        if (onlyWithDelivery) {
+          params.set('onlyWithDelivery', 'true');
+        }
         
         console.log('üåê API –∑–∞–ø—Ä–æ—Å:', `/api/search?${params.toString()}`);
         const response = await fetch(`/api/search?${params.toString()}`);
         const data = await response.json();
         
         console.log('üì¶ –û—Ç–≤–µ—Ç API:', data);
         
         let items = data.items || data.ads || [];
         
         if (activeFilter === 'fresh') {
           const now = new Date();
           items = items.filter((ad: Ad) => {
             const created = new Date(ad.createdAt);
             const hoursDiff = (now.getTime() - created.getTime()) / (1000 * 60 * 60);
             return hoursDiff < 48;
           });
         } else if (activeFilter === 'today') {
           const today = new Date();
           today.setHours(0, 0, 0, 0);
           items = items.filter((ad: Ad) => {
             const created = new Date(ad.createdAt);
             return created >= today;
           });
         }
         
         setAds(items);
         setTotalCount(items.length);
       } catch (error) {
         console.error('Search error:', error);
         setAds([]);
         setTotalCount(0);
       } finally {
         setLoading(false);
       }
     };
     
     fetchResults();
-  }, [query, userLat, userLng, selectedRadius, sortBy, activeFilter]);
+  }, [query, userLat, userLng, selectedRadius, sortBy, activeFilter, onlyWithDelivery]);
 
   const handleBack = () => {
     navigate(-1);
   };
 
   const handleSearch = (e: React.FormEvent) => {
     e.preventDefault();
     if (searchText.trim()) {
       navigate(`/search/results?q=${encodeURIComponent(searchText.trim())}`);
     }
   };
 
   const handleClearSearch = () => {
     setSearchText('');
   };
 
   const handleAdClick = (adId: string) => {
     navigate(`/ads/${adId}`);
   };
 
   const formatPrice = (price?: number) => {
     if (price === undefined || price === null) return '–¶–µ–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞';
     return `${price.toLocaleString('ru-RU')} —Ä—É–±.`;
   };
 
@@ -256,55 +261,73 @@ export default function SearchResultsPage() {
           padding: '0 12px 12px',
           overflowX: 'auto',
           WebkitOverflowScrolling: 'touch',
           scrollbarWidth: 'none',
           msOverflowStyle: 'none',
         }}>
           {filterChips.map((chip) => (
             <button
               key={chip.id}
               onClick={() => setActiveFilter(chip.id)}
               style={{
                 padding: '8px 16px',
                 borderRadius: 20,
                 border: chip.active ? 'none' : '1px solid #E5E7EB',
                 background: chip.active ? '#3A7BFF' : '#FFFFFF',
                 color: chip.active ? '#FFFFFF' : '#1F2937',
                 fontSize: 14,
                 fontWeight: 500,
                 whiteSpace: 'nowrap',
                 cursor: 'pointer',
                 flexShrink: 0,
                 transition: 'all 0.2s ease',
               }}
               data-testid={`filter-chip-${chip.id}`}
             >
-              {chip.label}
-            </button>
-          ))}
-        </div>
+            {chip.label}
+          </button>
+        ))}
+      </div>
+
+      <div style={{
+        display: 'flex',
+        alignItems: 'center',
+        justifyContent: 'flex-start',
+        padding: '0 16px 8px',
+        gap: 8,
+      }}>
+        <input
+          type="checkbox"
+          id="onlyDelivery"
+          checked={onlyWithDelivery}
+          onChange={(e) => setOnlyWithDelivery(e.target.checked)}
+        />
+        <label htmlFor="onlyDelivery" style={{ fontSize: 14, color: '#1F2937' }}>
+          –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å –¥–æ—Å—Ç–∞–≤–∫–æ–π
+        </label>
       </div>
+    </div>
 
       {/* Results Section */}
       <div style={{ flex: 1, padding: '12px 16px', paddingBottom: 100 }}>
 
         {/* Results Count + Sort */}
         <div style={{
           display: 'flex',
           alignItems: 'center',
           justifyContent: 'space-between',
           marginBottom: 16,
         }}>
           <span 
             style={{
               fontSize: 14,
               color: '#6B7280',
             }}
             data-testid="text-results-count"
           >
             –ù–∞–π–¥–µ–Ω–æ {totalCount} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
           </span>
           
           <button
             onClick={() => setShowSortSheet(true)}
             style={{
               display: 'flex',
@@ -433,50 +456,66 @@ export default function SearchResultsPage() {
                       position: 'absolute',
                       top: 8,
                       left: 8,
                       padding: '4px 10px',
                       background: '#22C55E',
                       borderRadius: 12,
                       fontSize: 11,
                       fontWeight: 600,
                       color: '#FFFFFF',
                     }}>
                       –°–≤–µ–∂–µ–µ
                     </div>
                   )}
                 </div>
 
                 {/* Info */}
                 <div style={{ padding: 12 }}>
                   <div style={{
                     fontSize: 16,
                     fontWeight: 600,
                     color: '#1F2937',
                     marginBottom: 4,
                   }}>
                     {formatPrice(ad.price)}
                   </div>
+                  {ad.hasDelivery && (
+                    <div style={{
+                      display: 'inline-flex',
+                      alignItems: 'center',
+                      gap: 4,
+                      background: '#E0F2FE',
+                      color: '#0C4A6E',
+                      borderRadius: 12,
+                      padding: '4px 8px',
+                      fontSize: 12,
+                      marginBottom: 6,
+                    }}>
+                      <span>üöö</span>
+                      <span>–î–æ—Å—Ç–∞–≤–∫–∞</span>
+                    </div>
+                  )}
                   <div style={{
                     fontSize: 13,
                     color: '#374151',
                     marginBottom: 6,
                     overflow: 'hidden',
                     textOverflow: 'ellipsis',
                     whiteSpace: 'nowrap',
                   }}>
                     {ad.title}
                   </div>
                   {ad.distanceKm !== undefined && (
                     <DistanceBadge distanceKm={ad.distanceKm} />
                   )}
                 </div>
               </div>
             ))}
           </div>
         )}
       </div>
 
       {/* Sort Sheet */}
       {showSortSheet && (
         <div
           style={{
             position: 'fixed',
diff --git a/models/Ad.js b/models/Ad.js
index dfb995fd1df358e0678fc12bbf094545f8b926d6..6e513adeb2eb1c4a5d6c8526842842819e9efc18 100644
--- a/models/Ad.js
+++ b/models/Ad.js
@@ -203,50 +203,76 @@ const adSchema = new mongoose.Schema(
       trim: true,
       default: null,
     },
     deliveryType: {
       type: String,
       enum: ['pickup_only', 'delivery_only', 'delivery_and_pickup'],
       default: undefined,
     },
     deliveryRadiusKm: {
       type: Number,
       min: 0,
       default: null,
     },
     seasonCode: {
       type: String,
       trim: true,
       lowercase: true,
       index: true,
     },
     storeId: {
       type: mongoose.Schema.Types.ObjectId,
       ref: 'SellerProfile',
       index: true,
       default: null,
     },
+    shopProfileId: {
+      type: mongoose.Schema.Types.ObjectId,
+      ref: 'SellerProfile',
+      index: true,
+      default: null,
+    },
+    hasDelivery: {
+      type: Boolean,
+      default: false,
+      index: true,
+    },
+    deliveryPriceOverride: {
+      type: Number,
+      min: 0,
+      default: null,
+    },
+    maxDailyQuantity: {
+      type: Number,
+      min: 0,
+      default: null,
+    },
+    availableQuantity: {
+      type: Number,
+      min: 0,
+      default: null,
+    },
     status: {
       type: String,
       enum: ['draft', 'active', 'sold', 'archived', 'hidden', 'expired', 'scheduled'],
       default: 'active',
       index: true,
     },
     
     // === Lifecycle Management ===
     lifetimeType: {
       type: String,
       enum: ['perishable_daily', 'fast', 'medium', 'long'],
       default: 'fast',
       index: true,
     },
     repeatMode: {
       type: String,
       enum: ['none', 'daily'],
       default: 'none',
     },
     repeatUntil: {
       type: Date,
       default: null,
     },
     expiresAt: {
       type: Date,
diff --git a/models/Order.js b/models/Order.js
index 25e8cae4832e20a17af55061b8c61af12d131d83..3ca23e6f44bdbf6d926dbc4e7895f111a553c429 100644
--- a/models/Order.js
+++ b/models/Order.js
@@ -19,92 +19,112 @@ const orderItemSchema = new mongoose.Schema(
     price: {
       type: Number,
       required: true,
       min: 0,
     },
     currency: {
       type: String,
       default: 'RUB',
     },
     sellerTelegramId: {
       type: Number,
       required: true,
     },
   },
   { _id: true }
 );
 
 const orderSchema = new mongoose.Schema(
   {
     user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true },
     buyerTelegramId: {
       type: Number,
       required: true,
       index: true,
     },
+    buyerId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true, default: null },
     buyerName: {
       type: String,
       trim: true,
     },
     buyerUsername: {
       type: String,
       trim: true,
     },
     buyerPhone: {
       type: String,
       trim: true,
     },
     items: {
       type: [orderItemSchema],
       required: true,
       validate: {
         validator: function (items) {
           return items && items.length > 0;
         },
         message: '–ó–∞–∫–∞–∑ –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ç–æ–≤–∞—Ä',
       },
     },
+    adId: { type: mongoose.Schema.Types.ObjectId, ref: 'Ad', index: true, default: null },
+    sellerId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true, default: null },
+    sellerTelegramId: { type: Number, index: true, default: null },
+    shopProfileId: {
+      type: mongoose.Schema.Types.ObjectId,
+      ref: 'SellerProfile',
+      index: true,
+      default: null,
+    },
     acceptedSellerIds: {
       type: [Number],
       default: [],
     },
     totalPrice: {
       type: Number,
       required: true,
       min: 0,
     },
     seasonCode: {
       type: String,
       trim: true,
       lowercase: true,
     },
     status: {
       type: String,
-      enum: ['new', 'processed', 'completed', 'cancelled'],
+      enum: ['new', 'processed', 'completed', 'cancelled', 'NEW', 'CONFIRMED', 'COMPLETED', 'CANCELLED'],
       default: 'new',
       index: true,
     },
+    scheduledDate: { type: Date, default: null, index: true },
+    deliveryRequired: { type: Boolean, default: false },
+    deliveryAddress: { type: String, trim: true, default: null },
+    deliveryLocation: {
+      lat: { type: Number },
+      lng: { type: Number },
+    },
     comment: {
       type: String,
       trim: true,
     },
   },
   {
     timestamps: true,
   }
 );
 
 // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–∞—Å—á–µ—Ç totalPrice –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω
 orderSchema.pre('save', function (next) {
   if (this.isNew && !this.totalPrice && this.items && this.items.length > 0) {
     this.totalPrice = this.items.reduce(
       (sum, item) => sum + item.price * item.quantity,
       0
     );
   }
   next();
 });
 
 orderSchema.index({ buyerTelegramId: 1, createdAt: -1 });
 orderSchema.index({ status: 1, createdAt: -1 });
+orderSchema.index({ sellerId: 1, scheduledDate: 1 });
+orderSchema.index({ shopProfileId: 1, scheduledDate: 1 });
+orderSchema.index({ adId: 1, scheduledDate: 1 });
 
 export default mongoose.model('Order', orderSchema);
diff --git a/models/SellerProfile.js b/models/SellerProfile.js
index 45f8e7891e353c806281daba3a63fb8e3c95b0e1..a0668b136bd305e4c9e51af4adf039a2e2b8fbfc 100644
--- a/models/SellerProfile.js
+++ b/models/SellerProfile.js
@@ -180,50 +180,85 @@ const sellerProfileSchema = new mongoose.Schema(
     },
     workingHours: {
       type: String,
       trim: true,
       default: null,
     },
     deliveryInfo: {
       type: String,
       trim: true,
       maxlength: 500,
       default: null,
     },
     showPhone: {
       type: Boolean,
       default: true,
     },
     region: {
       type: String,
       trim: true,
       default: null,
     },
     tags: [{
       type: String,
       trim: true,
     }],
+
+    // === Delivery & Roles ===
+    role: {
+      type: String,
+      enum: ['SHOP', 'FARMER', 'BLOGGER', 'ARTISAN'],
+      default: 'SHOP',
+    },
+    canDeliver: {
+      type: Boolean,
+      default: false,
+    },
+    deliveryRadiusKm: {
+      type: Number,
+      min: 0,
+      default: null,
+    },
+    defaultDeliveryPrice: {
+      type: Number,
+      min: 0,
+      default: null,
+    },
+
+    // === Verification ===
+    verificationLevel: {
+      type: String,
+      enum: ['basic', 'pro', null],
+      default: null,
+    },
+
+    // === Route Planning ===
+    baseLocation: {
+      lat: { type: Number },
+      lng: { type: Number },
+      address: { type: String, trim: true, default: null },
+    },
   },
   {
     timestamps: true,
   }
 );
 
 sellerProfileSchema.index({ name: 'text', description: 'text' });
 sellerProfileSchema.index({ 'geo': '2dsphere' });
 sellerProfileSchema.index({ subscribersCount: -1 });
 sellerProfileSchema.index({ 'ratings.score': -1 });
 sellerProfileSchema.index({ createdAt: -1 });
 
 sellerProfileSchema.statics.generateSlug = async function(name) {
   const baseSlug = name
     .toLowerCase()
     .replace(/[^a-z–∞-—è—ë0-9\s]/gi, '')
     .replace(/\s+/g, '-')
     .substring(0, 30);
   
   let slug = baseSlug;
   let counter = 1;
   
   while (await this.findOne({ slug })) {
     slug = `${baseSlug}-${counter}`;
     counter++;
