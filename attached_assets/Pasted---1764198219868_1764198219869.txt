Сделаем пока **минимальный, но живой кабинет магазина**, который реально нужен продавцу.

---

## Что будет в кабинете магазина (минимальный набор)

1. **Карточка магазина (шапка)**

   * Название магазина
   * Лого / аватар
   * Город / район
   * Короткое описание (1–2 строки)
   * Счётчик: `Активных товаров: N`
   * Кнопка: **«Открыть витрину»** (публичная страница магазина)

2. **Вкладка «Товары»**

   * Список объявлений этого магазина:

     * фото, заголовок, цена
     * статус: `Активно / Скрыто / Архив`
     * просмотры, избранное (если уже считается)
   * Действия по каждому:

     * переключатель **«Показывать / Скрыть»**
     * кнопка **«Редактировать»** (ведёт в текущий экран редактирования объявления)
   * Кнопка сверху/снизу: **«Добавить товар»** (открывает подачу объявления с привязкой к магазину).

3. **Вкладка «Статистика» (очень простая)**

   * За последние 7 дней:

     * Кол-во просмотров всех товаров
     * Кол-во кликов по контактам (телефон/Telegram)
     * Кол-во новых объявлений
   * Маленький summary:

     * «ТОП-3 товара по просмотрам» (только названия и цифры)

4. **Вкладка «Настройки магазина»**

   * Поля:

     * Название магазина
     * Лого (загрузка одной картинки)
     * Описание
     * Город / район
     * Телефон для связи
     * Telegram username
     * Переключатель: **«Показывать телефон в объявлениях»**
   * Кнопка **«Сохранить»**

---

## PROMPT ДЛЯ REPLIT / CODEX

(скопируй целиком и отдай ИИ-разработчику)

```text
Ты — senior full-stack разработчик KETMAR Market (Telegram MiniApp + backend).

Нужно сделать **минимальный кабинет магазина** для продавцов.

Стек:
- backend: Node.js + Express + MongoDB (Mongoose)
- frontend: React / TypeScript (MiniApp), уже есть навигация и вкладка «Профиль» / «Мои объявления».
- Авторизация: через уже реализованный текущий пользователь (currentUser).

ЗАДАЧА:
Реализовать сущность **Store (магазин)** и кабинет магазина с тремя вкладками:
1) Шапка магазина
2) Товары магазина
3) Статистика
4) Настройки

---

### 1. Модель Store в MongoDB

Создай модель `Store` (Mongoose):

- `ownerId: ObjectId` — ссылка на User (уникальный магазин на пользователя, пока по 1 магазину на владельца)
- `name: string` — название магазина (обязательное)
- `slug: string` — для публичной витрины (`ketmar.by/store/<slug>`, можно генерить из name)
- `logoUrl?: string`
- `description?: string`
- `city?: string`
- `region?: string`
- `phone?: string`
- `telegramUsername?: string`
- `showPhone: boolean` (по умолчанию true)
- `followersCount: number` (по умолчанию 0, на будущее)
- `createdAt: Date`
- `updatedAt: Date`

Добавь индекс:
- `{ ownerId: 1 }` (unique)

В модели `Ad`:
- добавь поле `storeId?: ObjectId` для привязки объявления к магазину.

При создании объявления через «кабинет магазина» мы будем передавать `storeId` — пока просто предусмотри это поле.

---

### 2. Backend API для магазина

Сделай новый router `storeRouter` под `/api/store`.

Нужные эндпоинты:

1) **Получить / создать магазин текущего пользователя**

`GET /api/store/me`

Логика:
- Найти Store по `ownerId = currentUser._id`.
- Если нет — создать дефолтный:
  - `name = "Мой магазин"`
  - остальные поля пустые
- Вернуть Store JSON.

2) **Обновить настройки магазина**

`PATCH /api/store/me`

Body:
- `name?`
- `logoUrl?`
- `description?`
- `city?`
- `region?`
- `phone?`
- `telegramUsername?`
- `showPhone?`

Обновить только разрешённые поля. Вернуть обновлённый Store.

3) **Список товаров магазина**

`GET /api/store/me/ads?status=active|hidden|archived`

- Найти Store по ownerId.
- Если нет Store — вернуть пустой список.
- Выбрать объявления (`Ad`) по `storeId = store._id`.
- Если есть query `status`, фильтровать по статусу (используй существующее поле, которое уже есть у Ad: `status` или аналог).
- Вернуть:
  - `_id, title, price, mainPhotoUrl, status, viewsCount, favoritesCount, createdAt`.

4) **Простая статистика магазина**

`GET /api/store/me/stats`

Сделай простую агрегацию по объявлениям магазина:

- `totalAds` — всего объявлений
- `activeAds` — статус `active`
- `viewsLast7Days` — сумма `viewsCount` за последние 7 дней (если у нас есть по дням, используй; если нет, просто `viewsCount` всех активных объявлений как временное решение)
- `contactsClicksLast7Days` — сумма `contactClicksCount` по объявлениям магазина (можно без фильтра по дате, но код подготовь с фильтром по createdAt, если поле уже есть).

Также верни массив `topAds`:
- ТОП-3 объявлений по `viewsCount` (id, title, viewsCount).

---

### 3. Frontend — кабинет магазина

В существующей MiniApp:

1. Добавь в «Профиль» кнопку/меню:

- Кнопка **«Мой магазин»**.
- По нажатию открывается новый экран `StoreCabinetScreen`.

2. Экран `StoreCabinetScreen`:

Состоит из:

#### 3.1. Шапка магазина

Вверх экрана:

- карточка с:
  - аватар (logoUrl или заглушка с буквой)
  - название магазина
  - строка: `Город, район` (если есть)
  - строка: `Активных товаров: N` (получаем из stats.activeAds)
- кнопка справа/снизу: **«Открыть витрину»** (пока можно сделать заглушку: alert или переход на `/store/:slug`, если такая страница уже есть/будет позже).

Для данных:
- при монтировании экрана — параллельные запросы:
  - `GET /api/store/me`
  - `GET /api/store/me/stats`

#### 3.2. Табы

Сделай 3 вкладки (простые segmented-control или tabs):

- **Товары**
- **Статистика**
- **Настройки**

##### Вкладка «Товары»

Контент:
- Кнопка сверху: **«Добавить товар»** — открывает уже существующий flow создания объявления. При открытии:
  - если есть возможность — добавь к payload `storeId = store._id` (в форме создания).
- Список товаров:
  - Запрос: `GET /api/store/me/ads`
  - Каждая карточка:
    - маленькое фото слева
    - справа: title, price
    - под ним: статус (`Активно / Скрыто`)
    - маленький текст: `Просмотры: X • В избранном: Y`
    - переключатель/кнопка: **«Скрыть / Показать»** (пока можно просто вызывать PATCH на `/api/ads/:id` со сменой статуса, используй уже существующий endpoint, если он есть. Если нет — добавь простой PATCH).
    - кнопка «Редактировать» → открывает текущий экран редактирования объявлений.

##### Вкладка «Статистика»

Использует данные из `GET /api/store/me/stats`:

Блоки:

- карта значений (можно просто карточки):

  - `Всего объявлений: totalAds`
  - `Активных: activeAds`
  - `Просмотры за 7 дней: viewsLast7Days`
  - `Клики по контактам за 7 дней: contactsClicksLast7Days`

- Блок «ТОП-товары»:

  - Список `topAds` (название + кол-во просмотров).

Никаких графиков пока не нужно — просто цифры.

##### Вкладка «Настройки»

Форма, предзаполненная значениями из `GET /api/store/me`:

Поля:

- Input: `Название магазина` (обязательное)
- Upload/кнопка: `Логотип` (используй уже существующий компонент загрузки картинок; логика аналогична фото объявлений, только 1 файл, сохраняем URL в `logoUrl`).
- Textarea: `Описание`
- Input: `Город`
- Input: `Район` (можно объединить с городом или отдельное поле)
- Input: `Телефон`
- Input: `Telegram username`
- Switch: `Показывать телефон в объявлениях` (`showPhone`)

Кнопка **«Сохранить»**:
- отправляет `PATCH /api/store/me`.
- после успешного ответа — обновляет локальное состояние и показывает тост «Настройки сохранены».

---

### 4. Технические детали и стиль

- Код пиши на TypeScript и аккуратно разделяй на:
  - `models/storeModel.ts`
  - `routes/storeRouter.ts`
  - `services/storeStatsService.ts` (если нужно)
  - `screens/StoreCabinetScreen.tsx` или аналогично по структуре проекта.
- Не ломай текущую логику подач объявлений — просто добавь опциональную поддержку `storeId`.
- Все новые эндпоинты должны быть защищены текущей middleware авторизации (используй ту, что уже есть для «Моих объявлений»).

Цель: **минимальный, рабочий кабинет магазина**, без сложных графиков и AI, но с:
- настройками магазина,
- списком товаров магазина,
- базовой статистикой.
```

Если захочешь дальше — можем поверх этого кабинета уже навесить PRO-аналитику (типа Avito Pro), витрину магазина и подписки.
