PROMPT ТОЛЬКО ДЛЯ BACKEND (Geo-MVP Phase 1)
Ты — senior backend-разработчик. Нужна доработка backend-части геомаркетплейса LOCALHUB / KETMAR Market.

Фронтенд и MiniApp уже частично готовы, геоинфраструктура в MongoDB есть, но бэкенд нужно довести до чёткого, предсказуемого и удобного API для геопоиска.

СДЕЛАЙ ВСЁ, ЧТО НИЖЕ ОПИСАНО, АККУРАТНО И С КОММЕНТАРИЯМИ В КОДЕ.

================================
1. ТЕКУЩИЙ КОНТЕКСТ BACKEND
================================

Технологии (предположительно, но уточни по репо!):
- Node.js,
- Express или Nest (скорее Express, но проверь),
- MongoDB + Mongoose,
- JWT-авторизация,
- уже есть модели `User`, `Ad` и т.д.

Важно:
- В модели объявления `Ad` уже есть поле `geo` в формате GeoJSON Point:
  geo: {
    type: { type: String, enum: ['Point'], default: 'Point' },
    coordinates: { type: [Number], required: true }, // [lng, lat]
  }

- На это поле повешен 2dsphere-индекс.
- Уже существует какой-то endpoint `/api/ads/nearby` и `/api/ads/search`, но их нужно:
  - унифицировать,
  - чётко поддержать параметры geo и сортировок,
  - гарантировать возврат поля `distanceKm` для фронта.

ЦЕЛЬ: привести backend к предсказуемому, стабильно работающему API геопоиска.

================================
2. ЦЕЛЕВЫЕ API ДЛЯ ГЕОПОИСКА
================================

Нужно, чтобы бэкенд надёжно поддерживал:

1) GET /api/ads/nearby
   Обязательное поведение:
   - Принимает query-параметры:
     - lat (число, широта),
     - lng (число, долгота),
     - radiusKm (число, радиус в километрах, по умолчанию 3).
   - Дополнительные фильтры:
     - categoryId (string, optional),
     - subcategoryId (string, optional),
     - cityId (string, optional),
     - search (string, optional),
     - sort (по умолчанию по distance; можно также поддержать дата/цена).

   - Возвращает JSON-массив объявлений, у каждого:
     - `_id`,
     - базовые поля (title, description, price, images, и т.д.),
     - поле `distanceKm: number` — расстояние от переданных координат до объявления, в КИЛОМЕТРАХ.

2) GET /api/ads/search
   - Обеспечить поддержку (опционально):
     - lat, lng, radiusKm, sort=distance
   - Если `sort=distance` и lat/lng заданы:
     - сортировать по расстоянию,
     - при желании тоже отдавать `distanceKm`.
   - Если нет координат — работать как обычный поиск, без расстояния.

Важно:
- API не должен падать при отсутствии lat/lng.
- Фронтенд может посылать запросы и без геопозиции — это норм.

================================
3. МОДЕЛЬ Ad (MONGOOSE)
================================

Найди модель `Ad` (скорее всего `models/Ad.ts` / `ad.model.ts` и т.п.).

Нужно:
1) Убедиться, что поле `geo` задано в формате GeoJSON Point:
   - type: 'Point',
   - coordinates: [lng, lat] (долгота, широта).

2) Если индекса нет — повесить 2dsphere-индекс:

   ```ts
   AdSchema.index({ geo: '2dsphere' });



Важно: поля geo должны быть required там, где это нужно (например, для активных объявлений), но не ломать существующие данные. Если в базе уже есть объявления без geo — предусмотрительно обработать этот кейс в запросах (просто не включать их в геопоиск).


Если модель уже корректна — просто проверь и прокомментируй в коде, что это поле используется для geo-поиска.
================================
4. /api/ads/nearby — ГЛАВНЫЙ ЭНДПОИНТ ГЕОПОИСКА
Найди существующий обработчик /api/ads/nearby (router/controller). Если его нет или он сырой — реализуй с нуля.
Требования:
4.1. Валидация входных параметров:


lat, lng — обязательны для геопоиска:


попытаться распарсить как число,


если невалидно — вернуть 400 с понятной ошибкой.




radiusKm — опциональный, по умолчанию 3 км:


минимальное значение, например, 0.1 км,


максимальное (например, 50–100 км), чтобы не палить всю базу разом.




4.2. Агрегация через $geoNear (предпочтительно) или $near:
Предпочтительный вариант — агрегат:
db.ads.aggregate([
  {
    $geoNear: {
      near: { type: 'Point', coordinates: [lng, lat] },
      distanceField: 'distanceMeters',
      maxDistance: radiusKm * 1000,
      spherical: true,
      query: { ...допфильтры } // категории, город, и т.д.
    }
  },
  { $sort: { distanceMeters: 1 } },
  // дополнительные стадии: фильтры по статусу, цене, etc.
])

Важно:


distanceField лучше назвать distanceMeters а затем на уровне JS конвертировать в distanceKm.


Не забыть spherical: true.


4.3. Фильтры:


Если передан categoryId — фильтровать по нему,


subcategoryId — тоже,


cityId — если у модели есть поле cityId / city,


search — по title/description (через $regex или textIndex, если есть).


Фильтры можно добавить либо в query $geoNear, либо в отдельные $match после.
4.4. Преобразование результата:


В данных агрегата будет поле distanceMeters.


На уровне Node-кода:


добавить distanceKm = distanceMeters / 1000,


округлять до, например, 3 знаков после запятой (или оставить в "сырых" метрах — главное, чтобы фронту было удобно).




В JSON-ответе:


либо включить distanceKm прямо в объект объявления,


либо вернуть как отдельное поле.




Желательно: сделать сериализацию так, чтобы фронт мог ожидать:
{
  "_id": "...",
  "title": "...",
  "price": 100,
  "geo": { "type": "Point", "coordinates": [27.5, 53.9] },
  "distanceKm": 2.34,
  ...
}

4.5. Обработка ошибок:


Любые исключения агрегации — ловим и возвращаем 500 с лаконичным сообщением + логируем в консоль/логгер.


4.6. Ограничение количества:


Ввести адекватный limit (например, 100 записей) либо из query-параметров (limit), либо жестко.


================================
5. /api/ads/search — ДОПОЛНИТЕЛЬНЫЙ ЭНДПОИНТ
Надо убедиться, что /api/ads/search корректно работает:


без geо — как обычный поиск,


и при наличии lat, lng, radiusKm и sort=distance — умеет учитывать расстояние.


Как минимум:
5.1. Принять из query:


lat, lng, radiusKm (optional),


sort (по умолчанию "date" или как сейчас в проекте),


остальные фильтры (categoryId, price, текст поиска и т.д.).


5.2. Варианты поведения:
Вариант А (простой):


Если нет lat/lng → оставить всё as-is, обычный поиск + старая сортировка.


Если есть lat/lng + sort=distance:


можно переиспользовать $geoNear так же, как в /nearby,


либо сначала $geoNear, потом остальные фильтры, либо наоборот.




Вариант B (более продвинутый):


Если есть lat/lng, но sort != distance:


всё равно можно добавить distanceKm в результат (но не сортировать по нему),


это позволит фронту показать расстояние даже при сортировке по цене/дате.




В любом случае:


не ломать существующую сигнатуру ответа,


аккуратно добавить distanceKm как опциональное поле.


================================
6. DTO / СЕРИАЛИЗАЦИЯ ОТВЕТОВ
Если в проекте есть слой DTO/mapper (например, функции вида mapAdToDTO или классы DTO в NestJS):
6.1. Добавить туда поддержку поля distanceKm:


В интерфейс/класс DTO добавить опциональное distanceKm?: number.


В mapper добавлять значение, если оно есть в документе/агрегате.


6.2. Проследить, чтобы distanceKm не протекало в лишние места (например, в админку, если там не нужно), либо разрешить — это не критично.
================================
7. ВАЛИДАЦИЯ И ТЕСТЫ


Для /nearby:




Если нет lat/lng → 400 с сообщением "lat and lng are required" (или аналогично).


Если radiusKm < минимального → поднимать до минимума.


Если radiusKm > максимального → обрезать до максимума.




Для /search:




Если lat/lng указаны, но невалидны → либо игнорировать, либо 400 (лучше валлидировать аккуратно).


Если sort=distance, но нет координат → либо игнорировать sort=distance и сортировать по умолчанию, либо вернуть 400. Лучше сделать безопасный fallback (не ошибка).




Unit-тесты (если в проекте уже есть тестовый стек):




Протестировать функцию, которая строит pipeline для $geoNear.


Протестировать конвертацию distanceMeters → distanceKm.


Если тестов нет — хотя бы добавить TODO-комментарии.
================================
8. ДОКУМЕНТАЦИЯ И КОММЕНТАРИИ
В конце:


Добавь JSDoc/комментарии к:


обработчику /api/ads/nearby,


местам, где происходит геоагрегация,


интерфейсам, где появилось distanceKm.




Если в проекте есть Swagger / OpenAPI:


Обнови описание эндпоинтов /api/ads/nearby и /api/ads/search:


Добавь параметры lat, lng, radiusKm, sort,


Пропиши, что в ответе есть поле distanceKm (optional).






================================
9. ВЫВОД ИЗМЕНЕНИЙ
В конце работы:


Выведи список изменённых файлов и краткое описание изменений для каждого (bullet-list).


Предложи название для ветки и коммита, например:


ветка: feature/backend-geo-mvp


коммит: feat(geo): add nearby endpoint, distanceKm and radius filters on backend.





---

Если нужно, сделаю следующий промт **отдельно под MiniApp UI** (только фронт, без бэка).
::contentReference[oaicite:0]{index=0}
