PROMPT №1 — Аналитика магазина (гистограммы, графики, антифрод)

Ты — senior fullstack dev в проекте KETMAR Market (Telegram MiniApp + Web + backend на Node/TS + Mongo/Postgres).
Нужно расписать и реализовать модуль аналитики для “Моего магазина” + базовый антифрод на основе данных по объявлениям и взаимодействиям пользователей.

Исходные сущности (можно переиспользовать / доопределить):

User

Shop (кабинет магазина, уже описан ранее)

ProductTemplate (карточка товара без цены)

Listing (конкретное объявление с ценой и количеством)

ViewEvent / FavoriteEvent / ContactViewEvent (events по объявлениям)

Complaint / Rating (жалобы и оценки по объявлениям/продавцам — можно ввести сейчас)

1. Цели модуля аналитики

Для владельца магазина:

Видеть в “Моём магазине”:

Сколько людей смотрят мои объявления по дням/неделям.

Какие товары заходят лучше всего.

Из каких районов/городов меня смотрят.

На каком расстоянии от моего магазина находятся потенциальные покупатели.

Как мои цены чувствуют себя относительно рынка (выше/ниже среднего по категории и региону).

По каждому объявлению (Listing):

График просмотров по дням.

Добавления в избранное.

Переходы к контактам (просмотр телефона/открытие чата).

Конверсия: просмотры → контакт (в процентах).

Геораспределение: топ районов, топ радиусных зон (0–2 км, 2–5 км, 5–10 км, 10+ км).

По магазину в целом:

Общая динамика спроса (просмотры всех объявлений).

Топ-5 товаров по просмотрам, добавлениям в избранное, контактам.

“Карта спроса” по районам (агрегация просмотров по агломерациям).

Для админа/антифрода:

Видеть:

“Подозрительные” магазины/продавцов.

Нормальное/слабое/подозрительное поведение по метрикам.

Распределение оценок и жалоб по продавцам и объявлениям.

Аномалии: резкие скачки цены, массовая серия однотипных объявлений, подозрительные жалобы.

2. События (events) и модели данных

Добавь/уточни следующие типы событий:

interface ViewEvent {
  id: string;
  userId?: string;            // может быть аноним
  listingId: string;
  shopId: string;
  ts: Date;
  location?: {
    lat: number;
    lng: number;
    city?: string;
    district?: string;
  };
}

interface FavoriteEvent {
  id: string;
  userId: string;
  listingId: string;
  shopId: string;
  ts: Date;
}

interface ContactViewEvent {
  id: string;
  userId: string;
  listingId: string;
  shopId: string;
  ts: Date;
}

type ComplaintReason =
  | 'fake_product'
  | 'wrong_price'
  | 'spam'
  | 'rude_seller'
  | 'other';

interface Complaint {
  id: string;
  listingId: string;
  shopId: string;
  fromUserId: string;
  reason: ComplaintReason;
  comment?: string;
  ts: Date;
}

interface Rating {
  id: string;
  targetType: 'listing' | 'shop';
  targetId: string;           // listingId или shopId
  fromUserId: string;
  value: 1 | 2 | 3 | 4 | 5;
  reasonCode?: string;        // для 1–3 можем спросить “что не так?”
  ts: Date;
}


Важно:

Все события должны сохраняться так, чтобы можно было эффективно агрегировать по:

shopId

listingId

дате (day bucket)

гео (city/district)

distance от магазина.

3. Backend API для аналитики магазина

Сделай отдельный модуль analytics с эндпоинтами:

Обзор магазина:

GET /shops/:shopId/analytics/overview?from=YYYY-MM-DD&to=YYYY-MM-DD

Возвращает:

totalViews — общее кол-во просмотров за период.

totalFavorites — добавления в избранное.

totalContactViews — переходы к контактам.

conversions:

viewToContactRate = totalContactViews / totalViews

dailySeries:

по дням: { date, views, favorites, contactViews }

topListingsByViews (ТОП N):

listingId, title, views, contactViews, conversionRate

geoDistribution:

по city/district: { city, district, views, uniqueUsers }

Аналитика по конкретному объявлению:

GET /shops/:shopId/listings/:listingId/analytics?from=&to=

Возвращает:

dailySeries по дням

geoDistribution (районы и дистанция)

distanceBuckets:

[0–2 км], [2–5], [5–10], [10+]

favoritesCount

contactViewsCount

complaintsSummary:

totalComplaints

byReason

ratingsSummary:

avgRating

countByValue (1..5)

Рыночная цена и “позиционирование” цены:

GET /shops/:shopId/listings/:listingId/price-position?region=...

На вход:

listingId

регион (по умолчанию — регион магазина: city/district).

На выход:

marketAvgPrice

marketMedianPrice

marketMinPrice

marketMaxPrice

sellerPrice

sellerPosition:

'below_market' | 'around_market' | 'above_market'

рекомендация в текстовом виде (краткая строка, можно генерить на бэке):

“Вы на 15% дешевле среднего по рынку в вашем районе”

“Вы на 25% дороже рынка, возможно, стоит пересмотреть цену”

4. UI/UX аналитики для владельца магазина

Во вкладке “Аналитика” кабинета магазина сделай следующие блоки:

Фильтр по периоду:

Быстрые пресеты: 7 дней, 30 дней, 90 дней.

Кастомный период.

Карточка “Общий обзор”:

Большие цифры:

Просмотры

Избранное

Переходы к контактам

Маленький текст: “за выбранный период”.

График “Спрос во времени” (line chart):

Ось X — дни.

Ось Y — просмотры.

Дополнительные линии:

favorites

contactViews

Наведение показывает конкретные значения.

Топ-товары:

Таблица/карточки:

Фото + название

Просмотры

Избранное

Контакты

Конверсия

Клик по товару → детальная аналитика по объявлению.

Гео-аналитика:

Вариант 1: списком по районам:

district: просмотры, доля (%).

Вариант 2: псевдо-heatmap/барчарт:

горизонтальная гистограмма по районам.

Распределение по дистанции (гистограмма):

4–5 бинов:

0–2 км

2–5 км

5–10 км

10+ км

Показываем:

количество просмотров.

Подпись: “Где находятся ваши покупатели относительно магазина”.

Аналитика по конкретному объявлению:

На отдельном экране/модалке:

График просмотров по дням.

Распределение по расстоянию.

Распределение по оценкам (1–5) — столбчатая диаграмма.

Блок с жалобами:

сколько и какие причины чаще всего.

Блок “Цена vs рынок”:

показываем текущую позицию и краткий текст.

Стиль: в нашем неон/матрица стиле, но без перегруза — чёрный фон, акцентные неоновые цвета, аккуратные карточки и графики.

5. Антифрод-аналитика (для админа)

Сделай отдельный раздел админки: “Антифрод и качество продавцов”.

Модель для “скоринга продавца”:

interface SellerQualityScore {
  shopId: string;
  score: number; // 0–100
  avgRating?: number;
  complaintsPer1000Views?: number;
  suspiciousFlags: string[]; // коды/причины
}


Пример логики расчёта (можно реализовать отдельным сервисом):

Базовый score = 100.

Минус за:

Высокую долю жалоб к просмотрам:

complaintRate = complaints / views.

Низкий средний рейтинг:

avgRating < 3 → сильный штраф.

Много объявлений с рейтингами 1–2.

Частые резкие изменения цены (например, >50% за день) — флаг.

Большое число жалоб “fake_product”, “wrong_price”.

Плюсы:

Высокий рейтинг 4–5 при приличном объёме.

Долгая “чистая” история без жалоб.

Сигналы (suspiciousFlags):

many_fake_complaints

price_spikes

too_many_low_ratings

suspicious_geo_pattern (если просмотры только из одной странной точки при широком радиусе)

many_deleted_listings_after_complaints (если объявления часто исчезают после жалоб)

Антифрод-UI:

Таблица магазинов с колонками:

Магазин (название)

Средний рейтинг

Кол-во жалоб

complaintRate (на 1000 просмотров)

SellerQualityScore (0–100)

Флаги

Статус магазина (approved/pending/paused/banned)

Фильтры:

Показать только магазины с score < 60.

Показать магазины с флагом many_fake_complaints и price_spikes.

При клике по магазину:

История объявлений.

График жалоб/оценок по времени.

Возможность:

поставить магазин на паузу,

отправить предупреждение (можно пока только предусмотреть эндпоинт и UI-заготовку).

Важно: антифрод — аналитический модуль для админа, без вмешательства в персональную жизнь, без жёсткого трекинга конкретных людей, только поведение в рамках платформы.

6. Архитектура и производительность

События (ViewEvent, FavoriteEvent, и т.д.) могут быть:

или в отдельной коллекции/таблице с индексами,

или предварительно агрегироваться в daily-агрегаты (например, nightly job).

Предусмотри:

индексы по shopId, listingId, ts.

агрегирующие запросы под основные отчёты (Mongo pipeline / SQL GROUP BY).

Код организуй модульно:

analyticsService с методами:

getShopOverviewAnalytics(shopId, from, to)

getListingAnalytics(listingId, from, to)

getPricePosition(listingId, region)

calculateSellerQualityScore(shopId).

PROMPT №2 — UX и логика “Ярмарок” внутри “Моего магазина”

Теперь сделай отдельный модуль “Ярмарки” (спецкампании) в рамках “Моего магазина”.

Контекст:

У нас есть сезонные ярмарки (8 марта – тюльпаны, Новогодняя ярмарка, осенняя ярмарка и т.п.).

Раньше мы описывали “фермерский кабинет” с ярмарками — нужно переиспользовать идею, но внедрить её внутри кабинета магазина.

1. Цель модуля “Ярмарки”

Для владельца магазина:

Видеть доступные сезонные кампании (ярмарки).

Одна кнопка — подключиться к ярмарке.

Для каждой ярмарки:

Установить спец-цены, лимиты по количеству.

Подготовить набор товаров, которые будут участвовать.

Быстро массово публиковать объявления по ярмарке.

Видеть аналитику по каждой ярмарке отдельно:

просмотры, контакты, заказы (если будут),

эффективность кампаний (какая ярмарка лучше отработала).

Для пользователя в ленте:

Отдельная визуальная промо-отметка, что это товар с ярмарки.

2. Модель данных для ярмарок

Опиши/введи сущность Fair (ярмарка):

type FairType = 'tulips_march8' | 'newyear_market' | 'autumn_fair' | 'custom';

interface Fair {
  id: string;
  code: string;                 // 'tulips_march8', ...
  title: string;                // “Весенняя тюльпан-ярмарка”
  description: string;
  type: FairType;

  startAt: Date;
  endAt: Date;

  isActive: boolean;
  // для UI
  bannerImageUrl?: string;
  colorTheme?: string;
  // какие категории товаров допустимы на ярмарке
  allowedCategoryIds?: string[];

  // какие роли продавцов могут участвовать (фермеры/магазины/частники)
  allowedSellerTypes?: ('farmer' | 'shop' | 'individual')[];

  createdAt: Date;
}


Теперь связь магазина с ярмаркой:

interface ShopFairParticipation {
  id: string;
  shopId: string;
  fairId: string;

  status: 'pending' | 'approved' | 'rejected' | 'active' | 'finished';

  // опциональные настройки магазина в рамках ярмарки
  specialNote?: string;
  preferredDelivery?: 'pickup' | 'courier' | 'both';

  createdAt: Date;
  updatedAt: Date;
}


И связь товара/объявлений с ярмаркой:

interface FairListing extends Listing {
  fairId: string;
  // можно унаследовать от Listing или добавить поле fairId к Listing
}

3. UX внутри кабинета магазина — вкладка “Ярмарки”

Добавь в “Мой магазин” новую вкладку: “Ярмарки”.

Вкладка состоит из трёх блоков:

Доступные ярмарки:

Список активных Fair, где:

isActive === true

дата сейчас в диапазоне [startAt, endAt]

магазин подходит под allowedSellerTypes.

Каждый элемент:

Баннер / иконка.

Название.

Краткое описание.

Даты проведения.

Кнопка:

“Участвовать”

Если уже участвует → “Перейти к настройкам”.

Мои участия:

Отдельный список ShopFairParticipation для текущего магазина:

статус (на модерации, одобрено, идёт, завершено).

число опубликованных ярмарочных товаров.

быстрые ссылки:

“Настроить товары”

“Посмотреть аналитику”.

Архив ярмарок:

Прошедшие ярмарки, где магазин участвовал.

Краткая статистика:

просмотры

контакты

best-selling товары.

4. Процесс участия магазина в ярмарке (онбординг)

При клике “Участвовать” на ярмарке:

Открываем шаг 1:

Информация о ярмарке.

Условия участия (текст/галочка).

Чекбокс: “Я согласен с условиями ярмарки”.

Кнопка “Продолжить”.

Шаг 2 — Настройки участия:

Доставка:

“Самовывоз”

“Доставка по городу/району”

Краткое описание магазина на ярмарке (отдельная витрина):

“Как быстро вы выдаете товар”

“Есть ли предзаказ” и т.п.

Шаг 3 — Подтверждение:

Кнопка “Отправить заявку на участие”.

Создаётся ShopFairParticipation со статусом pending.

Админская часть:

В админке:

список заявок по ярмаркам,

кнопки “Одобрить/Отклонить”.

При approve:

status = 'active'.

При reject:

status = 'rejected' + комментарий.

5. Настройка товаров для ярмарки

После одобрения участия (или сразу, если модерация не требуется) магазин должен:

Зайти в ярмарку → раздел “Товары на ярмарке”.

Интерфейс:

Таб “Из моих карточек товаров”:

Показываем ProductTemplate магазина, отфильтрованные по допустимым категориям ярмарки (allowedCategoryIds).

У каждого:

чекбокс “добавить в ярмарку”.

После выбора товаров:

для каждого выбранного:

поле “Ярмарочная цена”

поле “Количество (лимит на ярмарку)”

Кнопка “Опубликовать на ярмарке”:

создаём FairListing (либо Listing с fairId).

Особенности:

Место (location) берём из магазина.

В ленте такие объявления должны иметь ярмарочный бейдж/стикер:

напр. “Ярмарка 8 марта”, “Новогодняя ярмарка” и т.п.

6. Аналитика ярмарки для магазина

Внутри конкретной ярмарки для магазина добавить вкладку “Аналитика ярмарки”.

API:

GET /shops/:shopId/fairs/:fairId/analytics

Возвращает:

totalViews — просмотры всех ярмарочных объявлений магазина.

totalContactViews.

totalFavorites.

listings:

по каждому ярмарочному объявлению:

listingId, productTitle, views, contactViews, favorites, conversionRate.

dailySeries:

за весь период ярмарки.

geoDistribution:

районы/города, откуда смотрели ярмарочные товары.

distanceBuckets:

как в общей аналитике магазина, но только по ярмарочным объявлениям.

UI:

Карточка с суммарными показателями.

График “Спрос за время ярмарки”.

Таблица “ТОП-товары ярмарки”.

Гистограмма по районам.

7. Интеграция ярмарок в общую ленту объявления

При выводе объявлений в ленте:

Если listing.fairId заполнен:

В карточке:

бейдж “Ярмарка”.

текст “Участвует в: [название ярмарки]”.

Можно выводить ярмарку в отдельном разделе в ленте (“Блок ярмарки” сверху).

Фильтры:

В будущем предусмотреть:

фильтр “Показать только ярмарочные товары”.

фильтр по конкретной ярмарке.

8. Админка для ярмарок

Сделай базовый раздел админки “Ярмарки”:

Создание/редактирование Fair:

название, описание, даты, баннер.

allowedCategoryIds.

allowedSellerTypes.

Список магазинов-участников:

статус участия.

метрики:

просмотры

контакты

Возможность завершить ярмарку ранее endAt (меняем isActive).

9. Общие требования

Всё писать на TypeScript.

Переиспользовать:

существующий Shop, Listing, аналитику фермерского кабинета,

стили MiniApp.

Не ломать:

текущий API объявлений (лучше расширять моделями/флагами).

Код структурировать модулями:

fairService, shopFairService, fairAnalyticsService.