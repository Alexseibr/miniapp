Ты — senior full-stack (Node.js + TypeScript + React) в проекте KETMAR Market (Telegram MiniApp).

ПРОБЛЕМА СЕЙЧАС (ФАКТ):

На шаге «Фото товара» при попытке добавить фото появляется красный блок:

❌ «Не удалось получить URL для загрузки»

Кнопки:
- «Повторить»
- «Продолжить без фото»

UI уже реализован, но сама загрузка НЕ работает: не получается получить upload URL с backend.

НУЖНО:

1) Найти и починить полный цикл загрузки фото (получение URL → загрузка файла → сохранение ссылок в объявлении).
2) Оставить возможность пройти шаг **без фото**.
3) Сделать нормальную диагностику ошибок, чтобы в будущем было понятно, почему что-то упало.

РАБОТАЙ ПО ШАГАМ:

====================================================
1. НАЙТИ FRONTEND-КОД ЗАГРУЗКИ ФОТО И ОБРАБОТКИ ОШИБКИ
====================================================

Найди компонент шага «Фото товара» (по интерфейсу):

- что-то вроде:
  - `AdCreatePhotosStep.tsx`
  - `PhotosStep.tsx`
  - `CreateAdPhotosScreen.tsx`

и вспомогательные части:

- API-клиент для загрузки:
  - `uploadApi.ts`, `mediaApi.ts`, `filesApi.ts` или аналог,
  - функции наподобие:
    - `getUploadUrl`,
    - `requestUploadUrl`,
    - `uploadImageToUrl`.

Определи:

- какой именно **endpoint backend’а** вызывается:
  - `GET /api/uploads/url`
  - или `POST /api/media/presign`
  - или что-то похожее.

Проверь:

- что делает кнопка «Повторить»:
  - должна повторно выполнять запрос на получение upload URL;
  - если сейчас она только закрывает ошибку — поправь.

Сделай временный `console.log`:

- статус и тело ответа от backend для запроса upload URL;
- чтобы в логах было видно:
  - URL запроса,
  - statusCode,
  - текст ошибки (если backend присылает).

====================================================
2. ПРОВЕРИТЬ BACKEND-МАРШРУТ ПОЛУЧЕНИЯ UPLOAD URL
====================================================

Найди соответствующий маршрут на backend:

- по названию фронтового URL,
- или по поиску по коду: `getUploadUrl`, `presign`, `upload`, `signedUrl`.

Это может быть:

- `routes/uploads.ts`, `routes/media.ts`,
- контроллер `MediaController`, `UploadController` и т.п.

Проверь:

1) Какой СТОРАЖ используется:
   - S3/MinIO/Backblaze,
   - Google Cloud,
   - или локальная файловая система.

2) Какие ENV-переменные нужны:
   - `S3_BUCKET`, `S3_ACCESS_KEY`, `S3_SECRET_KEY`, `S3_REGION`, `MEDIA_BASE_URL`, и т.п.

3) Что именно сейчас ломается:
   - нет ENV → ошибка при инициализации клиента,
   - неверный bucket/region,
   - маршрут возвращает 500, 401 или 404,
   - некорректный JSON (фронт не может распарсить).

Сделай:

- аккуратный try/catch в обработчике:

```ts
router.post('/upload-url', async (req, res) => {
  try {
    // ... построить ключ, получить signed URL
    return res.json({ uploadUrl, fileUrl });
  } catch (err) {
    console.error('[upload-url] error', err);
    return res.status(500).json({
      error: 'UPLOAD_URL_FAILED',
      message: 'Не удалось получить URL для загрузки',
      details: process.env.NODE_ENV === 'development' ? String(err) : undefined
    });
  }
});
Важные моменты:

Убедись, что маршрут действительно возвращает:

uploadUrl — по которому фронт грузит файл PUT/POST,

fileUrl — готовый публичный (или полу-публичный) URL, который будем сохранять в объявление.

Фронт и бэк должны быть согласованы по:

HTTP-методу (PUT или POST на uploadUrl),

заголовкам (Content-Type и др.),

формату (если это form-data).

====================================================
3. ПРОТЕСТИРОВАТЬ ЦЕПОЧКУ: ПОЛУЧЕНИЕ URL → ЗАГРУЗКА ФАЙЛА
После починки эндпоинта сделай тест:

Из фронта/миниаппа:

нажми «Добавить»,

выбери фото из галереи или камеры,

проверь, что:

запрос /api/...upload-url возвращает 200,

в ответе есть uploadUrl и fileUrl.

Убедись, что следующий запрос отправляется на сам storage:

на https://s3...,

или другой host (зависит от провайдера).

Проверь:

что не падает CORS,

что методы и заголовки совпадают с требованиями хранилища,

что по fileUrl картинка реально открывается (в браузере, при необходимости с auth).

Если нужен поток:

PUT uploadUrl → сразу грузим бинарник file,

по завершению отображаем превью по fileUrl.

====================================================
4. СДЕЛАТЬ ГРАМОТНУЮ ОБРАБОТКУ ОШИБОК НА ФРОНТЕ
Если запрос на upload-url упал:

показываем в UI уже имеющийся блок ошибки:

текст: "Не удалось получить URL для загрузки",

кнопки:

"Повторить" → повторяет запрос getUploadUrl(),

"Продолжить без фото" → просто завершает шаг, НЕ блокируя мастер.

Убедись, что:

после нескольких неудачных попыток пользователь всё равно может:

нажать «Продолжить без фото» → перейти на следующий шаг мастера,

мастер доходит до публикации, даже если фото не было загружено.

Если ошибка происходит на этапе загрузки файлов (на uploadUrl):

показываем сообщение:

"Не удалось загрузить файл. Попробуйте ещё раз или продолжите без фото."

снова оставляем две кнопки: «Повторить загрузку» / «Продолжить без фото».

====================================================
5. ОПЦИОНАЛЬНО: ЛОКАЛЬНЫЙ РЕЖИМ БЕЗ S3 (ДЛЯ DEV)
Если в dev нет доступа к облаку, сделай упрощённый режим:

если ENV USE_LOCAL_UPLOADS=true:

вместо presigned URL:

принимаем файл через обычный POST /api/uploads,

сохраняем в uploads/ на диске,

возвращаем fileUrl как /uploads/<filename>.

Важно:

Не ломать prod-режим,

Разделить логику по ENV.

====================================================
6. ФИНАЛЬНАЯ ПРОВЕРКА МАСТЕРА
Проверь 3 сценария от начала до публикации:

Фото успешно загрузилось:

добавили 1–4 фото,

ошибок нет,

дошли до публикации,

в карточке объявления видим фото.

Ошибка получения URL:

backend отдаёт 500,

фронт показывает красный блок,

«Повторить» → можно повторить запрос (когда ты починил бэк),

«Продолжить без фото» → переходит на следующий шаг, мастер НЕ ломается, объявление создаётся без фото.

Ошибка на загрузке в storage:

имитируешь плохую сеть или неверный uploadUrl,

фронт показывает понятное сообщение,

всё равно можно «Продолжить без фото».

====================================================
7. В КОНЦЕ — КОРОТКИЙ ОТЧЁТ
После правок:

выведи список изменённых файлов и опиши в 1–2 строки:

AdCreatePhotosStep.tsx — логика повторной попытки и "продолжить без фото".

uploadApi.ts — обработка ошибок, логирование, сигнатура ответа.

uploads.routes.ts / media.controller.ts — фикс генерации presigned URL, try/catch.

storageClient.ts — конфиг стора и ENV.

предложи ветку и коммит:

ветка: fix/photo-upload-url

коммит: fix(media): stabilize upload URL endpoint and allow continue without photos

yaml
Копировать код
