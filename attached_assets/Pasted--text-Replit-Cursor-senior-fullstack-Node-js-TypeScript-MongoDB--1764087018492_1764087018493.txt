Скопируй всё между text и в Replit/Cursor.

Ты — senior fullstack (Node.js + TypeScript + MongoDB + React) в проекте KETMAR Market.

Контекст:
- Мы делаем гео-маркетплейс с мастер-созданием объявления.
- У нас НЕТ ещё полного дерева категорий (как у OLX/Kufar).
- Категории должны развиваться ПОСТЕПЕННО, на основе реальных объявлений.
- Уже есть сервис подсказки категории по тексту (title+description).

НУЖНО СДЕЛАТЬ:

1) Архитектуру категорий с поддержкой:
   - "узкого" стартового дерева (10–15 базовых категорий),
   - подкатегорий,
   - подкатегории вида **“Прочее в категории”**,
   - флага `needsCategoryReview` для объявлений, которым не нашли нормальную категорию.

2) Алгоритм поведения, когда:
   - подходящей подкатегории ещё нет,
   - уверенность подсказки низкая,
   - или человек выбрал "Прочее".

3) Механику **авто-предложения новых категорий**:
   - анализируем объявления в “Прочее”,
   - ищем повторяющиеся слова,
   - когда их много — предлагаем администратору создать новую подкатегорию.

4) Простую, понятную UX-логку выбора категории на фронте:
   - подсказка на основе текста,
   - fallback-мастер "Что вы продаёте?" с плитками (Телефон, Авто, Недвижимость, Фермерские продукты, Сельхозтехника, Услуги, Одежда, Другое),
   - всегда даём человеку возможность изменить категорию вручную.

===================================
1. МОДЕЛЬ КАТЕГОРИИ В БД
===================================

Расширь модель Category примерно до следующего вида:

```ts
interface Category {
  _id: ObjectId;
  parentId?: ObjectId | null;   // null для корневых категорий
  slug: string;                 // 'real-estate', 'electronics', 'fermer-products', ...
  name: string;                 // 'Недвижимость', 'Электроника', ...

  level: number;                // 0 - root, 1 - подкатегория, 2 - подподкатегория

  // Системные флаги
  isOther?: boolean;            // это "Прочее в категории"
  isActive: boolean;            // включена/выключена
  sortOrder: number;            // порядок в списке

  // На будущее: тип (товар, услуга, недвижимость и т.п.)
  type?: 'product' | 'service' | 'real-estate' | 'vehicle' | 'agro';

  createdAt: Date;
  updatedAt: Date;
}


Для каждой крупной категории (root) создай подкатегорию Прочее:

slug: 'other', isOther: true.

Примеры стартового дерева (HARDCODE или миграция):

electronics

phones-and-tablets

laptops

tv

electronics-other (isOther = true)

fermer-products

vegetables

fruits

berries

honey

fermer-other (isOther = true)

agro-tech

tractors

combines

agro-other (isOther = true)

real-estate

flats

houses

land

real-estate-other (isOther = true)

и т.д. (можешь сделать стартовый набор сам, но без фанатизма: 8–10 root категорий, у каждой по 3–5 подкатегорий + "Прочее").

===================================
2. ПОВЕДЕНИЕ ПРИ СОЗДАНИИ ОБЪЯВЛЕНИЯ

2.1. Сервис подсказки категории

Уже есть/будет CategorySuggestService.suggestByText(text):

возвращает bestMatch (categoryId, confidence).

При вводе заголовка/описания на фронте:

делаем debounce-запрос к /api/categories/suggest,

показываем подсказку: "Мы подобрали категорию: Электроника → Телефоны и планшеты".

2.2. Логика выбора категории

Во время мастера:

Если bestMatch.confidence >= 0.6:

предзаполняем форму этой категорией,

показываем пользователю:

"Категория: Электроника → Телефоны и планшеты (можно изменить)".

Пользователь может:

оставить,

открыть селектор и выбрать что-то другое.

Если confidence < 0.6 или в дереве нет такой категории:

НЕ автозаполняем,

показываем fallback-экран "Что вы продаёте?" с плитками:

Телефоны и электроника

Авто и транспорт

Квартира / Дом

Фермерские продукты

Сельхозтехника

Услуги

Одежда

Другое

После выбора плитки:

показываем соответствующие подкатегории,

если там нет подходящей → человек выбирает Прочее.

2.3. Сохранение объявления

В модели объявления (Ad):

interface Ad {
  // ...
  categoryId: ObjectId;
  // ...
  needsCategoryReview?: boolean; // см. ниже
}


Устанавливаем флаг:

если объявление попало в подкатегорию isOther === true:

needsCategoryReview = true,

иначе:

needsCategoryReview = false.

===================================
3. "МУСОРКА": ЛОГИКА ДЛЯ "ПРОЧЕЕ"

Если по всем правилам/подсказкам:

ничего нормального не нашли,

или пользователь выбрал "Прочее в [категория]",

то:

Мы ПУСКАЕМ объявление дальше (не блокируем UX).

В Ad.categoryId пишем id подкатегории с isOther: true.

Ставим needsCategoryReview = true.

Так у нас есть:

рабочие объявления,

понятный флаг, что они "висят" в мусорке и требуют структурирования.

===================================
4. АНАЛИЗ "ПРОЧЕЕ" И АВТО-ПРОПОЗАЛ НОВЫХ КАТЕГОРИЙ

Создай сервис/cron CategoryEvolutionService, который:

раз в N часов/дней (например, 1 раз в день),

проходит по категориям isOther = true,

для каждой такой категории:

Находит все объявления:

categoryId = otherCategoryId,

needsCategoryReview = true.

Для этих объявлений:

формирует текст title + description,

прогоняет через normalizeAndTokenize,

считает самые частые слова/фразы.

Если:

таких объявлений > MIN_ADS_FOR_NEW_SUBCATEGORY (например, 20),

и есть слова/фразы, которые явные (например, "ягоды", "трактор", "запчасти", "кухни"),

→ создаёт предложение в админке:

interface CategoryProposal {
  _id: ObjectId;
  parentCategoryId: ObjectId;     // в какой root/подкатегории создаём
  suggestedName: string;          // 'Ягоды', 'Тракторы', 'Запчасти к тракторам'
  keywordsSample: string[];       // топовые слова, по которым выкатили
  matchedAdsCount: number;        // сколько объявлений уже подходит
  status: 'pending' | 'approved' | 'rejected';
  createdAt: Date;
}


Админка:

страница "Предложения по категориям":

видит список CategoryProposal,

по клику видит выборку объявлений, на которых основано предложение,

нажимает:

"Создать категорию" → создаётся новая подкатегория, объявления из "Прочее" переносятся туда, needsCategoryReview = false,

"Отклонить" → статус rejected.

===================================
5. UX НА ФРОНТЕ: МАКСИМАЛЬНО ПРОСТО ДЛЯ ПОЛЬЗОВАТЕЛЯ

Сделай на шаге выбора категории:

Блок подсказки (если есть bestMatch):

“Мы подобрали категорию: Электроника → Телефоны и планшеты”

Кнопки:

Применить (автозаполняет select’ы),

Выбрать другую (скрывает подсказку, показывает плиточный мастер).

Плиточный выбор (fallback):

большой заголовок: “Что вы продаёте?”

плитки (по стартовому дереву):

Недвижимость

Авто и транспорт

Телефоны и электроника

Фермерские продукты

Сельхозтехника

Услуги

Одежда и обувь

Другое

Пользователь нажимает, например, “Фермерские продукты”:

ниже показывается список подкатегорий:

Овощи

Фрукты

Ягоды

Мёд

Прочее

если ничего не подходит — он выбирает Прочее, и наш backend уже пометит needsCategoryReview.

Никогда не заставляем человека видеть длинный дропдаун из 200 позиций; максимум 5–7 выборов на экран.

===================================
6. ФИНАЛЬНО: ЧТО ИМЕННО СДЕЛАТЬ В КОДЕ

Backend:

обновить модель Category (isOther, level, type).

написать миграцию/скрипт создания стартового дерева категорий.

добавить поле needsCategoryReview в Ad.

при сохранении объявления:

если категория isOther === true → needsCategoryReview = true,

иначе false.

реализовать CategoryEvolutionService:

сбор объявлений, висящих в Прочее,

подбор часто встречающихся слов,

создание CategoryProposal.

сделать API/модель CategoryProposal + эндпоинты для админки (получить список, approve/reject).

Frontend:

на шаге деталей:

интегрировать подсказку /api/categories/suggest,

блок "мы подобрали категорию",

fallback-плитки по типам товаров,

после выбора плитки — компактный список подкатегорий c опцией Прочее.

не давать пользователю ощущение «я не знаю куда отнести товар»:

у каждой плитки есть Прочее в этой теме.

В комментариях к PR коротко документировать:

как добавить новую root-категорию,

как добавлять подкатегории вручную,

как в админке работать с предложениями категорий.