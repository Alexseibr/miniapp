import Category from '../models/Category.js';
import CategorySuggestService from './CategorySuggestService.js';
import { normalizeText } from '../utils/textTokenizer.js';
import {
  ICON_3D_KEYWORD_MAP,
  PARENT_CATEGORY_FALLBACKS,
  findIcon3dByKeywords,
  generateSubcategorySlug,
  generateSubcategoryTitle
} from '../config/icon3dMappingConfig.js';

const KEYWORD_TO_PARENT_CATEGORY = {
  'порошок': 'dom-sad',
  'стиральный': 'dom-sad',
  'чистящее': 'dom-sad',
  'моющее': 'dom-sad',
  'кофе': 'farmer-market',
  'чай': 'farmer-market',
  'велосипед': 'hobbi-sport-turizm',
  'самокат': 'hobbi-sport-turizm',
  'инструмент': 'remont-stroyka',
  'дрель': 'remont-stroyka',
  'посуда': 'dom-sad',
  'книга': 'hobbi-sport-turizm',
  'гантели': 'hobbi-sport-turizm',
  'косметика': 'krasota-zdorove-tovary',
  'крем': 'krasota-zdorove-tovary',
  'парфюм': 'krasota-zdorove-tovary',
  'детский': 'tovary-dlya-detey',
  'игрушка': 'tovary-dlya-detey',
  'пелёнка': 'tovary-dlya-detey',
  'антиквариат': 'hobbi-sport-turizm',
  'гитара': 'hobbi-sport-turizm',
  'палатка': 'hobbi-sport-turizm',
  'удочка': 'hobbi-sport-turizm',
  'ручная работа': 'hobbi-sport-turizm',
  'офисный': 'elektronika',
  'принтер': 'elektronika',
  'медицинский': 'krasota-zdorove-tovary',
  'люстра': 'dom-sad',
  'светильник': 'dom-sad',
  'постельное': 'dom-sad',
  'шторы': 'dom-sad',
  'сладости': 'farmer-market',
  'продукты': 'farmer-market',
};

class AutoCategorizationService {
  async autoCategorizeAd({ title, description = '' }) {
    const text = `${title || ''} ${description || ''}`.trim();
    
    if (!text || text.length < 3) {
      return this.getFallbackResult('Текст слишком короткий');
    }

    try {
      const suggestionResult = await CategorySuggestService.suggest(title, description);
      
      if (suggestionResult.bestMatch && suggestionResult.bestMatch.categoryId) {
        return {
          categoryId: suggestionResult.bestMatch.categoryId,
          categoryName: suggestionResult.bestMatch.categoryName,
          categorySlug: suggestionResult.bestMatch.categorySlug,
          subcategoryId: suggestionResult.bestMatch.subcategoryId,
          subcategoryName: suggestionResult.bestMatch.subcategoryName,
          subcategorySlug: suggestionResult.bestMatch.subcategorySlug,
          confidence: suggestionResult.bestMatch.confidence || 0.8,
          source: suggestionResult.bestMatch.source || 'rules+stats',
          reason: `Найдено по ключевым словам: ${(suggestionResult.bestMatch.matchedKeywords || []).join(', ')}`,
          createdSubcategory: null,
          alternatives: suggestionResult.alternatives || []
        };
      }

      return await this.createAutoSubcategory(text);
    } catch (error) {
      console.error('[AutoCategorization] Error:', error);
      return this.getFallbackResult(error.message);
    }
  }

  async createAutoSubcategory(text) {
    const normalizedText = normalizeText(text);
    const extractedKeywords = this.extractKeywords(normalizedText);
    
    const parentCategorySlug = this.determineParentCategory(normalizedText);
    
    const parentCategory = await Category.findOne({ 
      slug: parentCategorySlug,
      level: 1,
      isActive: true 
    });

    if (!parentCategory) {
      return this.getFallbackResult('Не найдена родительская категория');
    }

    const iconResult = findIcon3dByKeywords(text);
    
    const newSlug = generateSubcategorySlug(parentCategorySlug, extractedKeywords);
    const newTitle = generateSubcategoryTitle(extractedKeywords);
    
    const existingSubcategory = await Category.findOne({ slug: newSlug });
    if (existingSubcategory) {
      return {
        categoryId: parentCategory._id.toString(),
        categoryName: parentCategory.name,
        categorySlug: parentCategory.slug,
        subcategoryId: existingSubcategory._id.toString(),
        subcategoryName: existingSubcategory.name,
        subcategorySlug: existingSubcategory.slug,
        confidence: 0.6,
        source: 'auto_existing',
        reason: `Найдена существующая авто-категория: ${existingSubcategory.name}`,
        createdSubcategory: null,
        alternatives: []
      };
    }

    const newSubcategory = new Category({
      slug: newSlug,
      name: newTitle,
      parentSlug: parentCategorySlug,
      level: 2,
      isLeaf: true,
      icon3d: iconResult.icon3d,
      keywordTokens: extractedKeywords,
      sourceKeywords: extractedKeywords,
      autoGenerated: true,
      autoGeneratedAt: new Date(),
      visible: false,
      isDynamic: true,
      dynamicMinCountLocal: 5,
      dynamicMinCountCountry: 10,
      isActive: true,
      sortOrder: 999
    });

    await newSubcategory.save();

    console.log(`[AutoCategorization] Created new subcategory: ${newSlug} under ${parentCategorySlug}`);

    return {
      categoryId: parentCategory._id.toString(),
      categoryName: parentCategory.name,
      categorySlug: parentCategory.slug,
      subcategoryId: newSubcategory._id.toString(),
      subcategoryName: newSubcategory.name,
      subcategorySlug: newSubcategory.slug,
      confidence: 0.5,
      source: 'auto_created',
      reason: `Создана новая подкатегория "${newTitle}" на основе ключевых слов`,
      createdSubcategory: {
        _id: newSubcategory._id.toString(),
        slug: newSubcategory.slug,
        name: newSubcategory.name,
        icon3d: newSubcategory.icon3d,
        keywordTokens: newSubcategory.keywordTokens,
        isAutoGenerated: true,
        isVisible: false
      },
      alternatives: []
    };
  }

  extractKeywords(text) {
    const stopWords = new Set([
      'и', 'в', 'на', 'с', 'по', 'для', 'из', 'к', 'от', 'до', 'за', 'при',
      'под', 'над', 'без', 'или', 'не', 'но', 'а', 'то', 'как', 'что', 'это',
      'всё', 'все', 'только', 'уже', 'ещё', 'так', 'же', 'бы', 'ли', 'ни',
      'продам', 'продаю', 'продажа', 'куплю', 'купить', 'отдам', 'даром',
      'новый', 'новая', 'новое', 'бу', 'б/у', 'цена', 'торг', 'срочно',
      'шт', 'штук', 'штука', 'кг', 'литр', 'руб', 'рублей'
    ]);

    const words = text.toLowerCase()
      .replace(/[^а-яёa-z0-9\s]/gi, ' ')
      .split(/\s+/)
      .filter(word => word.length >= 3 && !stopWords.has(word));

    const uniqueWords = [...new Set(words)];
    
    return uniqueWords.slice(0, 5);
  }

  determineParentCategory(text) {
    const normalizedText = text.toLowerCase();
    
    for (const [keyword, categorySlug] of Object.entries(KEYWORD_TO_PARENT_CATEGORY)) {
      if (normalizedText.includes(keyword)) {
        return categorySlug;
      }
    }
    
    return 'inoe';
  }

  async getFallbackResult(reason) {
    const otherCategory = await Category.findOne({ 
      $or: [
        { slug: 'inoe' },
        { slug: 'other' },
        { isOther: true }
      ],
      level: 1,
      isActive: true 
    });

    if (otherCategory) {
      return {
        categoryId: otherCategory._id.toString(),
        categoryName: otherCategory.name,
        categorySlug: otherCategory.slug,
        subcategoryId: null,
        subcategoryName: null,
        subcategorySlug: null,
        confidence: 0.1,
        source: 'fallback',
        reason: reason || 'Не удалось определить категорию',
        createdSubcategory: null,
        alternatives: []
      };
    }

    return {
      categoryId: null,
      categoryName: 'Иное',
      categorySlug: 'inoe',
      subcategoryId: null,
      subcategoryName: null,
      subcategorySlug: null,
      confidence: 0,
      source: 'error',
      reason: reason || 'Категория не найдена',
      createdSubcategory: null,
      alternatives: []
    };
  }

  async updateVisibilityByAdCount(minAdsCount = 5) {
    try {
      const Ad = (await import('../models/Ad.js')).default;
      
      const autoGeneratedCategories = await Category.find({
        autoGenerated: true,
        visible: false,
        isActive: true
      });

      let updatedCount = 0;

      for (const category of autoGeneratedCategories) {
        const adCount = await Ad.countDocuments({
          $or: [
            { categoryId: category._id },
            { subcategoryId: category._id }
          ],
          status: 'active'
        });

        if (adCount >= minAdsCount) {
          await Category.updateOne(
            { _id: category._id },
            { $set: { visible: true } }
          );
          updatedCount++;
          console.log(`[AutoCategorization] Made visible: ${category.slug} (${adCount} ads)`);
        }
      }

      return { updatedCount, checkedCount: autoGeneratedCategories.length };
    } catch (error) {
      console.error('[AutoCategorization] Error updating visibility:', error);
      return { updatedCount: 0, error: error.message };
    }
  }

  async getAutoGeneratedStats() {
    const totalAutoGenerated = await Category.countDocuments({ autoGenerated: true });
    const visibleAutoGenerated = await Category.countDocuments({ autoGenerated: true, visible: true });
    const hiddenAutoGenerated = await Category.countDocuments({ autoGenerated: true, visible: false });

    return {
      total: totalAutoGenerated,
      visible: visibleAutoGenerated,
      hidden: hiddenAutoGenerated
    };
  }
}

export default new AutoCategorizationService();
